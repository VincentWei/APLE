1
00:00:00,200 --> 00:00:01,333
今天这个第一讲

2
00:00:01,333 --> 00:00:02,500
就是讲内存管理

3
00:00:02,500 --> 00:00:04,933
我为什么选这个内存管理作为第一讲

4
00:00:04,933 --> 00:00:06,200
就是因为内存管理呢

5
00:00:06,200 --> 00:00:09,700
实质上在 Linux 基础的这个环境里边

6
00:00:09,700 --> 00:00:10,466
去编程的时候

7
00:00:10,466 --> 00:00:12,800
它是一个非常非常基础的一个主题

8
00:00:13,333 --> 00:00:15,333
你去讲什么都绕不开这个

9
00:00:15,333 --> 00:00:17,966
而且我们很多的这个程序的问题

10
00:00:17,966 --> 00:00:20,500
就是因为内存管理不善导致的

11
00:00:20,900 --> 00:00:21,533
这也是为什么

12
00:00:21,533 --> 00:00:23,666
后来有 Rust 语言的这个出现吧

13
00:00:23,666 --> 00:00:25,300
所以这个呢大家了解

14
00:00:25,300 --> 00:00:26,766
所以我们就把这个内容呢

15
00:00:26,766 --> 00:00:29,566
作为一个主要的最最关键的一个内容

16
00:00:29,566 --> 00:00:31,766
今天呢第一讲就给大家讲这个

17
00:00:32,100 --> 00:00:33,300
那大概的内容是这样

18
00:00:33,300 --> 00:00:36,500
就是我先给大家讲一些虚拟内存原理

19
00:00:36,500 --> 00:00:37,733
当然很多人可能知道

20
00:00:37,733 --> 00:00:39,600
我们大概梳理一下就行了

21
00:00:39,600 --> 00:00:41,000
因为我这个不是讲内核的

22
00:00:41,000 --> 00:00:43,166
所以也不会陷入到细节当中

23
00:00:43,400 --> 00:00:43,666
然后呢

24
00:00:43,666 --> 00:00:46,900
我马上会进入到 C/C++ 程序的这个堆和栈的

25
00:00:46,900 --> 00:00:48,666
这个管理的一些基本的东西

26
00:00:48,666 --> 00:00:49,533
原理概念

27
00:00:49,533 --> 00:00:52,366
然后呢包括它的这个一个流程等等的

28
00:00:52,566 --> 00:00:53,500
然后我们再来看看

29
00:00:53,500 --> 00:00:55,200
常见的内存的使用问题

30
00:00:55,200 --> 00:00:58,366
以及我们为了解决这些问题

31
00:00:58,366 --> 00:00:59,700
又出现了很多工具

32
00:00:59,700 --> 00:01:00,066
是吧

33
00:01:00,066 --> 00:01:01,566
这些工具怎么去弄

34
00:01:01,700 --> 00:01:04,266
那我们还会总结一下

35
00:01:04,266 --> 00:01:07,200
就是说如果我们想在 C/C++ 程序当中

36
00:01:07,200 --> 00:01:09,566
避免常见的这些内存使用问题

37
00:01:09,566 --> 00:01:12,333
我们应该怎么样去利用这个内存

38
00:01:12,666 --> 00:01:14,466
然后呢就是我们给大家讲一讲

39
00:01:14,466 --> 00:01:16,000
这个实际上就是拓展性的

40
00:01:16,000 --> 00:01:17,166
大型项目的内存管理

41
00:01:17,166 --> 00:01:20,300
比如说是像大型的 C/C++ 的这个程序

42
00:01:20,300 --> 00:01:20,766
举个例子

43
00:01:20,766 --> 00:01:22,866
比如说是像那个 Webkit

44
00:01:22,866 --> 00:01:24,200
这种浏览器引擎

45
00:01:24,333 --> 00:01:26,000
它的内存管理是怎么做的

46
00:01:26,366 --> 00:01:28,800
然后还有一些脚本语言解释器

47
00:01:28,800 --> 00:01:31,066
它的这种管理是怎么做的

48
00:01:31,066 --> 00:01:31,800
这样的话

49
00:01:31,800 --> 00:01:33,300
通过拓展这些内容

50
00:01:33,366 --> 00:01:34,800
让大家对这个东西呢

51
00:01:34,800 --> 00:01:37,333
整个有一个更深刻的这个理解

52
00:01:37,700 --> 00:01:39,500
首先呢，就是说虚拟内存的原理

53
00:01:39,500 --> 00:01:41,433
我不打算做很多的这个

54
00:01:41,433 --> 00:01:42,933
深入的这个讲解

55
00:01:42,933 --> 00:01:44,766
实际上在这个预习的内容里面

56
00:01:44,766 --> 00:01:45,900
我也把这个列出来了

57
00:01:45,900 --> 00:01:47,000
主要的目的是什么

58
00:01:47,000 --> 00:01:47,933
就是大家要知道

59
00:01:47,933 --> 00:01:49,266
现在在Linux上

60
00:01:49,266 --> 00:01:51,500
那基本上都是在虚拟内存

61
00:01:51,500 --> 00:01:52,700
这个基础之上

62
00:01:53,000 --> 00:01:54,366
去管理这个内存

63
00:01:54,533 --> 00:01:55,366
虚拟内存呢

64
00:01:55,366 --> 00:01:57,933
实质上它提供了一个很好的东西

65
00:01:57,933 --> 00:02:00,333
比如说是地质空间的这个保护，是吧

66
00:02:00,333 --> 00:02:00,800
然后呢

67
00:02:00,800 --> 00:02:02,533
还有这个各种各样的这些好处

68
00:02:02,533 --> 00:02:03,733
虚拟内存带来了

69
00:02:04,166 --> 00:02:06,200
那它的这个实现里边

70
00:02:06,400 --> 00:02:09,500
实质上是硬件和软件配合的

71
00:02:09,533 --> 00:02:11,133
这里面其中硬件呢

72
00:02:11,133 --> 00:02:12,166
主要的一个东西呢

73
00:02:12,166 --> 00:02:15,366
叫做 MMU 就是内存管理单元

74
00:02:15,400 --> 00:02:17,700
那就是 CPU 里面的一个很小的模块

75
00:02:17,700 --> 00:02:18,933
内存管理单元

76
00:02:19,400 --> 00:02:21,166
然后和软件配合

77
00:02:21,166 --> 00:02:22,000
这个软件是什么

78
00:02:22,000 --> 00:02:22,666
就是内核

79
00:02:22,666 --> 00:02:25,166
就是内核在跟这个 MMU 配合

80
00:02:25,466 --> 00:02:26,133
然后呢

81
00:02:26,133 --> 00:02:29,066
中间的这个关联的这个东西

82
00:02:29,066 --> 00:02:32,266
就是它们之间建立起这个关联的东西

83
00:02:32,333 --> 00:02:33,966
就叫页表

84
00:02:33,966 --> 00:02:35,066
就是 page table

85
00:02:35,400 --> 00:02:37,366
这个 page table 实质上指什么呢

86
00:02:37,366 --> 00:02:38,866
就是在内核里边

87
00:02:38,866 --> 00:02:40,666
去分配物理内存的时候

88
00:02:40,666 --> 00:02:42,966
我们通常是以页为单位的

89
00:02:42,966 --> 00:02:43,933
这个页是什么呢

90
00:02:43,933 --> 00:02:44,800
就是 4KB

91
00:02:45,166 --> 00:02:49,400
就是说我们有一大段块的这个内存

92
00:02:49,400 --> 00:02:50,200
物理内存

93
00:02:50,566 --> 00:02:51,900
比如说是我这个配置呢

94
00:02:51,900 --> 00:02:53,266
是 8GB 是吧

95
00:02:53,666 --> 00:02:56,266
那么内核

96
00:02:56,266 --> 00:02:57,766
它去管理这些东西的时候

97
00:02:57,766 --> 00:02:59,366
一定是以 4KB

98
00:02:59,366 --> 00:03:00,066
现在基本上

99
00:03:00,066 --> 00:03:02,733
4KB 的这个大小是一个标配了

100
00:03:02,933 --> 00:03:03,666
以前的时候呢

101
00:03:03,666 --> 00:03:05,166
比如说 64 位系统上

102
00:03:05,166 --> 00:03:07,866
可能它会变成 8KB 或者 16KB 什么的

103
00:03:07,866 --> 00:03:11,366
但是现在基本上以
4KB 为单位去管理它

104
00:03:11,733 --> 00:03:13,600
我在内核里面去分配内存

105
00:03:13,600 --> 00:03:15,766
包括我们在应用

106
00:03:15,766 --> 00:03:17,100
用户态就是进程

107
00:03:17,100 --> 00:03:18,800
用户进程这一级去分配内存

108
00:03:18,800 --> 00:03:19,900
实际上分配到的东西

109
00:03:19,900 --> 00:03:22,266
它都是以 4KB 为单位

110
00:03:22,266 --> 00:03:24,700
4KB 为单位的这样的一个东西

111
00:03:24,800 --> 00:03:25,766
所以这个东西呢

112
00:03:25,766 --> 00:03:26,866
就叫 page

113
00:03:27,700 --> 00:03:29,566
然后在内存里面分配的时候呢

114
00:03:29,566 --> 00:03:31,200
它可能就是不连续的

115
00:03:32,000 --> 00:03:33,100
一定要注意

116
00:03:33,133 --> 00:03:35,000
比如说它这个东西呢

117
00:03:35,000 --> 00:03:35,800
很乱吧

118
00:03:35,933 --> 00:03:38,800
就像我们把物理内存当做一个堆一样

119
00:03:38,800 --> 00:03:40,166
我分配来分配去

120
00:03:40,300 --> 00:03:43,300
它始终是不可能变成连续的

121
00:03:43,300 --> 00:03:43,700
对吧

122
00:03:43,700 --> 00:03:46,133
比如说一会是这一块分配了

123
00:03:46,133 --> 00:03:47,133
又把它释放了

124
00:03:47,133 --> 00:03:47,533
然后呢

125
00:03:47,533 --> 00:03:49,866
你下一次被分配在别的地方，对吧

126
00:03:49,900 --> 00:03:50,900
它不可能连续

127
00:03:51,700 --> 00:03:54,666
那我们要在这个虚拟地址空间

128
00:03:54,666 --> 00:03:56,600
就用户态的这个进程里面

129
00:03:56,600 --> 00:03:59,366
它去访问我们的虚拟的地址空间的时候

130
00:03:59,500 --> 00:04:00,800
我们一定要注意

131
00:04:00,800 --> 00:04:05,166
我们的这些地址在逻辑上

132
00:04:05,166 --> 00:04:07,133
就是在虚拟的那个地址空间里面

133
00:04:07,133 --> 00:04:08,666
它是连续的，对吧

134
00:04:08,866 --> 00:04:10,666
所以呢一定要有一个表

135
00:04:11,266 --> 00:04:12,533
这个表干什么呢

136
00:04:12,533 --> 00:04:14,566
就是做虚拟地址

137
00:04:14,900 --> 00:04:17,533
和物理地址之间的映射

138
00:04:17,533 --> 00:04:20,000
它实际上就完成了这么一个工作，对吧

139
00:04:20,200 --> 00:04:21,800
这是物理地址

140
00:04:21,800 --> 00:04:23,400
4K 4K 的

141
00:04:24,966 --> 00:04:27,366
然后呢这是虚拟的地址空间

142
00:04:27,366 --> 00:04:28,966
比如说是 0-4GB

143
00:04:29,466 --> 00:04:29,866
这是什么

144
00:04:29,866 --> 00:04:32,500
32 位系统上 0-4 GB，对吧

145
00:04:32,533 --> 00:04:33,866
那这个页表呢

146
00:04:33,866 --> 00:04:36,200
哎它就是一个映射关系

147
00:04:36,366 --> 00:04:38,333
然后通过这指向这

148
00:04:38,333 --> 00:04:40,200
比如说这个 4K

149
00:04:40,200 --> 00:04:41,300
从底下开始吧

150
00:04:41,300 --> 00:04:42,333
这个 4K 呢

151
00:04:42,333 --> 00:04:44,133
指向这这个 4K 呢

152
00:04:44,133 --> 00:04:45,200
指向这啊

153
00:04:45,200 --> 00:04:46,466
再往上这个 4K 呢

154
00:04:46,466 --> 00:04:47,700
指向这啊

155
00:04:48,166 --> 00:04:49,266
当然你也实际上

156
00:04:49,266 --> 00:04:49,966
理论上啊

157
00:04:49,966 --> 00:04:50,566
这个东西呢

158
00:04:50,566 --> 00:04:52,000
可以不同的页

159
00:04:52,000 --> 00:04:54,333
可以指向同一个物理地址

160
00:04:54,333 --> 00:04:55,700
也是可能的啊

161
00:04:55,700 --> 00:04:58,066
这就是这个基本的这个概念

162
00:04:58,566 --> 00:05:00,400
那这个页表啊

163
00:05:00,466 --> 00:05:01,333
它给我们

164
00:05:01,333 --> 00:05:03,333
提供了这么一个转换关系嘛

165
00:05:03,333 --> 00:05:05,366
那页表是谁在维护呢

166
00:05:05,366 --> 00:05:06,366
内核在维护

167
00:05:06,500 --> 00:05:08,400
那页表保存在哪呢

168
00:05:08,600 --> 00:05:11,300
那页表本身也是要需要存储空间的

169
00:05:11,300 --> 00:05:11,733
对吧

170
00:05:11,733 --> 00:05:12,866
所以的话呢

171
00:05:12,866 --> 00:05:15,366
页表呢也是保存在这个物理地址

172
00:05:15,366 --> 00:05:16,633
物理内存里边的

173
00:05:16,633 --> 00:05:18,566
比如说这一块啊

174
00:05:18,566 --> 00:05:21,033
就是一个某一个进程的页表

175
00:05:21,233 --> 00:05:22,200
这个页表啊

176
00:05:22,200 --> 00:05:24,266
它是以进程为单位保存的

177
00:05:24,400 --> 00:05:26,733
每一个进程都会有一个页表，是吧

178
00:05:26,800 --> 00:05:27,533
所以的话呢

179
00:05:27,533 --> 00:05:30,766
就是说这个页表逻辑地址到物理地址

180
00:05:30,766 --> 00:05:32,333
它实际上就是个映射表

181
00:05:32,366 --> 00:05:33,633
这个映射表呢

182
00:05:33,933 --> 00:05:35,266
有很多讲究

183
00:05:35,266 --> 00:05:36,433
我们今天呢

184
00:05:36,433 --> 00:05:38,133
不会去细节的去讲

185
00:05:38,133 --> 00:05:40,100
我们现在以问题为单位

186
00:05:40,100 --> 00:05:42,033
去过一下这个基本的原理

187
00:05:42,166 --> 00:05:44,933
第一个问题就是页表是以进程为单位

188
00:05:44,933 --> 00:05:46,433
还是以处理器为单位的

189
00:05:46,433 --> 00:05:48,100
这个我刚才实际上回答了

190
00:05:48,333 --> 00:05:50,266
页表它是以进程为单位的

191
00:05:50,266 --> 00:05:51,566
那第二个问题

192
00:05:52,100 --> 00:05:53,500
页表本身保存在哪里

193
00:05:53,500 --> 00:05:55,066
只要刚才这个问题呢

194
00:05:55,266 --> 00:05:57,466
就是大家都说了哎

195
00:05:57,666 --> 00:05:58,266
这个东西呢

196
00:05:58,266 --> 00:06:00,966
它就是实际上本身也要存储在这个

197
00:06:01,566 --> 00:06:03,166
这个物理地址里面

198
00:06:03,166 --> 00:06:03,900
对吧

199
00:06:03,900 --> 00:06:05,066
然后呢

200
00:06:05,733 --> 00:06:06,566
第三个问题

201
00:06:06,933 --> 00:06:08,133
我们估计一下

202
00:06:08,133 --> 00:06:11,200
一个最简单的 C 程序进程一启动

203
00:06:11,266 --> 00:06:12,500
比如说就是 hello word

204
00:06:12,600 --> 00:06:15,133
它需要多少页表项

205
00:06:15,266 --> 00:06:16,433
这里边指的是什么

206
00:06:16,433 --> 00:06:17,166
页表啊

207
00:06:17,466 --> 00:06:21,633
页表它实际上就是一个索引表

208
00:06:21,633 --> 00:06:23,000
就是这么一个索引表

209
00:06:23,466 --> 00:06:24,866
那这个索引表呢

210
00:06:25,400 --> 00:06:26,833
一般来讲的话呢

211
00:06:26,833 --> 00:06:29,166
它的，比如说 32 位，对吧

212
00:06:29,166 --> 00:06:29,900
32 位

213
00:06:29,900 --> 00:06:31,633
然后它会有一部分呢

214
00:06:31,633 --> 00:06:33,266
就是这个指向 offset 

215
00:06:33,366 --> 00:06:34,466
这个一部分指什么

216
00:06:34,466 --> 00:06:35,266
就是 4KB

217
00:06:35,266 --> 00:06:36,200
4KB 是多少

218
00:06:36,433 --> 00:06:38,400
不就是 12bits

219
00:06:38,966 --> 00:06:40,066
它是底下的 12bits

220
00:06:40,066 --> 00:06:40,933
就是这个

221
00:06:41,333 --> 00:06:43,833
最后会认识到这里边的一个 offset

222
00:06:43,833 --> 00:06:45,366
然后前面的这部分呢

223
00:06:45,366 --> 00:06:48,566
它是一个页表项的一个索引值

224
00:06:48,633 --> 00:06:51,200
它是这样一个就是说机制

225
00:06:51,433 --> 00:06:53,800
那页表项通常来讲的话呢

226
00:06:53,800 --> 00:06:54,400
4KB

227
00:06:54,400 --> 00:06:56,300
它是 4KB 为单位

228
00:06:56,300 --> 00:06:59,066
我们如果假设

229
00:06:59,066 --> 00:07:01,466
这个页表是个一级页表

230
00:07:01,500 --> 00:07:02,766
那我们可以看到

231
00:07:02,766 --> 00:07:06,200
比如说我们要分配一个 0-4G 的

232
00:07:06,200 --> 00:07:07,966
这个虚拟地址空间的话

233
00:07:08,200 --> 00:07:09,233
大家想一想

234
00:07:09,466 --> 00:07:11,800
这个页表项一共得有多少项

235
00:07:12,066 --> 00:07:13,200
或者是我们说

236
00:07:13,366 --> 00:07:14,566
就是 0-4G

237
00:07:14,566 --> 00:07:16,600
整个 0-4G 我全都用了

238
00:07:16,600 --> 00:07:19,833
某一个进程把这个 0-4GB 全都用了

239
00:07:20,000 --> 00:07:22,000
它需要多少的这个页表项

240
00:07:23,266 --> 00:07:24,566
多少个页表项

241
00:07:24,733 --> 00:07:25,600
实际上很简单

242
00:07:25,600 --> 00:07:27,266
就是除以 4K，对吧

243
00:07:27,266 --> 00:07:28,800
就是 4GB 除以 4K

244
00:07:29,000 --> 00:07:29,666
对不对

245
00:07:29,666 --> 00:07:31,666
就是除法就除出来了

246
00:07:31,666 --> 00:07:32,366
那这个东西呢

247
00:07:32,366 --> 00:07:33,200
实际上很大

248
00:07:33,200 --> 00:07:34,533
因为每一个页表项

249
00:07:34,533 --> 00:07:36,166
基本上是也是 32 位的

250
00:07:36,166 --> 00:07:37,133
也就是 4 字节

251
00:07:37,400 --> 00:07:37,866
所以的话呢

252
00:07:37,866 --> 00:07:38,866
再乘以 4

253
00:07:38,966 --> 00:07:41,000
也就相当于除以 1K，对吧

254
00:07:41,033 --> 00:07:41,933
哎对

255
00:07:42,066 --> 00:07:42,866
说的很对啊

256
00:07:42,866 --> 00:07:44,000
4GB 除以 4KB

257
00:07:44,033 --> 00:07:45,466
然后呢每一个页表项呢

258
00:07:45,466 --> 00:07:47,500
是比如说 32 位，是吧

259
00:07:47,500 --> 00:07:48,833
然后呢那有的乘以 4

260
00:07:48,833 --> 00:07:50,433
也就是 4GB 除以 1KB

261
00:07:50,700 --> 00:07:53,266
这个显然是非常非常大的，对吧

262
00:07:53,266 --> 00:07:55,666
就是说这个显然是非常非常大的

263
00:07:56,100 --> 00:07:56,700
所以的话呢

264
00:07:56,700 --> 00:07:59,433
实际上在我们的真实的这个系统里边

265
00:07:59,666 --> 00:08:01,300
或者是处理器里边

266
00:08:01,533 --> 00:08:04,466
它实际上是这个页表是分级的

267
00:08:04,466 --> 00:08:05,533
页表是分级的

268
00:08:06,233 --> 00:08:08,233
就是二级页表

269
00:08:08,233 --> 00:08:09,533
或者三级页表

270
00:08:09,666 --> 00:08:10,400
那通常呢

271
00:08:10,400 --> 00:08:12,100
现在 64 位的系统

272
00:08:12,100 --> 00:08:13,133
64 位的架构

273
00:08:13,133 --> 00:08:16,733
比如说 RISC-V ，ARM64，AMD64

274
00:08:16,733 --> 00:08:19,333
这些架构都是三级页表

275
00:08:19,333 --> 00:08:21,533
就是为了让它的这个处理

276
00:08:21,533 --> 00:08:24,066
能够更高效

277
00:08:24,066 --> 00:08:25,533
就占用的内存更小

278
00:08:25,533 --> 00:08:27,000
如果只有一级页表的话

279
00:08:27,000 --> 00:08:29,866
你想一个进程就要占这么多，对吧

280
00:08:30,100 --> 00:08:31,733
那系统里面有很多个进程

281
00:08:31,733 --> 00:08:33,200
你这玩意怎么玩，对吧

282
00:08:33,200 --> 00:08:34,200
就没法玩了

283
00:08:34,266 --> 00:08:34,833
所以的话呢

284
00:08:34,833 --> 00:08:37,533
它是一级二级三级这样子的

285
00:08:37,533 --> 00:08:38,266
这样子的东西

286
00:08:38,266 --> 00:08:41,033
我们先简单把这个内存管理的原理

287
00:08:41,033 --> 00:08:42,533
首先呢过一下

288
00:08:42,566 --> 00:08:44,100
我们接着往下讲

289
00:08:44,300 --> 00:08:45,166
虚拟内存技术

290
00:08:45,166 --> 00:08:47,066
它实际上带来很多好处

291
00:08:47,233 --> 00:08:49,100
就比如说进程间的内存共享

292
00:08:49,100 --> 00:08:50,433
它带来很多便利

293
00:08:50,633 --> 00:08:51,833
多个进程

294
00:08:52,466 --> 00:08:53,100
大家都知道

295
00:08:53,100 --> 00:08:56,466
所有的 C 程序都需要链接 glibc，对不对

296
00:08:56,566 --> 00:08:58,566
那链接 glibc 的时候

297
00:08:58,566 --> 00:09:01,266
一个 glibc 可能就好几兆了

298
00:09:01,333 --> 00:09:02,666
那它的大部分数据

299
00:09:02,666 --> 00:09:03,533
比如说代码

300
00:09:03,833 --> 00:09:05,066
一定是只读的嘛

301
00:09:05,133 --> 00:09:05,833
对不对

302
00:09:05,833 --> 00:09:06,533
只读的

303
00:09:06,533 --> 00:09:07,100
这个时候呢

304
00:09:07,100 --> 00:09:10,466
我就可以在多个进程间共享

305
00:09:10,466 --> 00:09:11,966
这个呢也很好理解

306
00:09:12,266 --> 00:09:13,633
就是刚才我们不是说嘛

307
00:09:13,633 --> 00:09:15,033
虚拟地址是吧

308
00:09:15,300 --> 00:09:16,233
然后呢

309
00:09:16,333 --> 00:09:17,433
虚拟地址底下呢

310
00:09:17,433 --> 00:09:20,533
有很多不同的进程

311
00:09:20,666 --> 00:09:22,533
它的同一个虚拟地址呢

312
00:09:22,700 --> 00:09:23,966
可以指向什么呢

313
00:09:23,966 --> 00:09:25,166
指向这个

314
00:09:25,666 --> 00:09:26,266
指向这个

315
00:09:26,266 --> 00:09:28,366
一个以 4K 页为单位

316
00:09:28,366 --> 00:09:29,566
比如说这块呢叫

317
00:09:29,566 --> 00:09:34,466
我们接下来会讲叫 text 的这个段

318
00:09:34,666 --> 00:09:36,233
然后呢

319
00:09:39,100 --> 00:09:40,500
但是它真正指向的

320
00:09:40,500 --> 00:09:44,333
比如说是 Libc 库的这块代码

321
00:09:44,833 --> 00:09:45,633
那它是什么呢

322
00:09:45,633 --> 00:09:46,266
这些东西呢

323
00:09:46,266 --> 00:09:48,100
就是指向的同一个位置

324
00:09:48,633 --> 00:09:50,700
如果呢是另外一个进程

325
00:09:50,700 --> 00:09:53,733
这个 Pro A 

326
00:09:53,733 --> 00:09:55,500
这个 Proc B

327
00:09:55,933 --> 00:09:57,400
那它的同样的这个

328
00:09:57,400 --> 00:09:58,933
如果是连接到这个

329
00:10:00,033 --> 00:10:01,733
也是连接到 Libc

330
00:10:01,900 --> 00:10:03,300
那它一样的

331
00:10:03,300 --> 00:10:05,366
也是指向同样的东西

332
00:10:05,633 --> 00:10:06,466
同样的东西

333
00:10:06,533 --> 00:10:07,133
这样的话呢

334
00:10:07,133 --> 00:10:07,800
实际上它就

335
00:10:08,433 --> 00:10:10,366
就是说在整个系统里面

336
00:10:10,366 --> 00:10:14,466
如果我装载的动态库是同一个

337
00:10:14,533 --> 00:10:15,666
多个进程之间

338
00:10:15,666 --> 00:10:18,033
它实际上是可以共享这些东西的

339
00:10:18,033 --> 00:10:19,100
共享这些东西

340
00:10:19,100 --> 00:10:20,166
页表项不一样

341
00:10:20,166 --> 00:10:22,733
但实际的物理内存是同一个

342
00:10:22,733 --> 00:10:23,566
这是同一个

343
00:10:23,633 --> 00:10:25,333
这是它带来的一个好处啊

344
00:10:25,366 --> 00:10:25,933
第二个呢

345
00:10:25,933 --> 00:10:26,533
大家都知道

346
00:10:26,533 --> 00:10:27,633
就在 Linux 底下

347
00:10:27,633 --> 00:10:30,266
你可以设置交换分区

348
00:10:30,266 --> 00:10:31,466
或者是交换文件

349
00:10:31,466 --> 00:10:31,800
对吧

350
00:10:31,800 --> 00:10:34,133
交换文件可以用来干什么呢

351
00:10:34,233 --> 00:10:36,566
就是用来把一些不活跃的内存

352
00:10:36,900 --> 00:10:39,500
先给他临时倒腾到这个文件里面存着

353
00:10:39,500 --> 00:10:41,466
它需要的时候再给它装载进来

354
00:10:41,633 --> 00:10:42,066
这样的话呢

355
00:10:42,066 --> 00:10:44,266
比如说你内存比较紧张的时候

356
00:10:44,266 --> 00:10:45,733
那我们会发现很多进程呢

357
00:10:45,733 --> 00:10:46,566
它实际上在那

358
00:10:46,566 --> 00:10:47,666
一直在那停着

359
00:10:47,666 --> 00:10:47,966
对吧

360
00:10:47,966 --> 00:10:49,133
它也没什么工作

361
00:10:49,133 --> 00:10:51,266
我又不能把它杀掉

362
00:10:51,266 --> 00:10:51,866
那这个时候呢

363
00:10:51,866 --> 00:10:53,066
我把它的这个东西呢

364
00:10:53,066 --> 00:10:55,166
就先扔到这个文件里边

365
00:10:55,166 --> 00:10:56,833
然后腾出来物理内存

366
00:10:56,933 --> 00:10:57,533
给别人

367
00:10:57,533 --> 00:10:58,166
需要的东西呢

368
00:10:58,166 --> 00:10:59,266
我再给它用

369
00:10:59,266 --> 00:11:02,500
这就是这个交换文件/分区它的作用

370
00:11:02,500 --> 00:11:03,633
这个大家也都懂

371
00:11:03,766 --> 00:11:05,033
那虚拟内存技术呢

372
00:11:05,033 --> 00:11:06,866
就带来这么一个好处啊

373
00:11:06,866 --> 00:11:08,166
然后呢还有什么呢

374
00:11:08,166 --> 00:11:10,233
就比如说是写时复制

375
00:11:10,333 --> 00:11:12,133
用时分配等等的

376
00:11:12,133 --> 00:11:14,566
提高整体系统的这个性能

377
00:11:14,666 --> 00:11:15,566
举个简单的例子

378
00:11:15,566 --> 00:11:18,366
我要在内存里面分配一块非常巨大的

379
00:11:18,366 --> 00:11:19,300
这个内存

380
00:11:19,533 --> 00:11:21,233
就比如说是 1M

381
00:11:21,433 --> 00:11:22,133
1M 的话呢

382
00:11:22,133 --> 00:11:25,100
大概是需要多少的页呢

383
00:11:25,700 --> 00:11:28,833
1024K 除以 4

384
00:11:28,833 --> 00:11:29,666
那就是什么呢

385
00:11:29,666 --> 00:11:32,200
就是 256 个页

386
00:11:32,266 --> 00:11:32,966
对不对

387
00:11:32,966 --> 00:11:34,400
那 256 个页

388
00:11:34,533 --> 00:11:35,666
我分配了

389
00:11:35,833 --> 00:11:36,733
假如

390
00:11:36,733 --> 00:11:42,333
我这个刚好是一共有 256 个 page

391
00:11:42,933 --> 00:11:44,866
这 256 个 page 呢

392
00:11:45,133 --> 00:11:46,533
但是呢我用的时候

393
00:11:46,533 --> 00:11:48,533
我程序分配了这么大的内存

394
00:11:48,533 --> 00:11:50,000
但实际上我用的时候呢

395
00:11:50,000 --> 00:11:52,800
并不是说一下子就把这些内存给用完

396
00:11:52,800 --> 00:11:53,500
对吧

397
00:11:54,433 --> 00:11:55,333
那怎么用

398
00:11:55,333 --> 00:11:57,333
它有可能是一点一点用

399
00:11:57,333 --> 00:12:01,433
我们再举一个非常非常特殊的例子

400
00:12:01,600 --> 00:12:03,333
什么呢？就是稀疏矩阵

401
00:12:03,633 --> 00:12:05,333
大家都知道稀疏矩阵吧

402
00:12:08,500 --> 00:12:10,633
比如说我分割的这么大的一个内存

403
00:12:10,633 --> 00:12:11,666
就是要干什么呢

404
00:12:11,666 --> 00:12:13,200
就是存储

405
00:12:13,200 --> 00:12:15,100
就是一个很稀疏的矩阵

406
00:12:15,133 --> 00:12:16,633
这个稀疏矩阵什么意思呢

407
00:12:16,633 --> 00:12:18,233
就是大概这么一个

408
00:12:18,233 --> 00:12:21,033
比如说是 n 乘 m 的一个矩阵

409
00:12:21,466 --> 00:12:23,100
 m 行 n 列

410
00:12:23,100 --> 00:12:24,066
这样的一个矩阵

411
00:12:24,133 --> 00:12:25,833
但是只有这些上面呢有数

412
00:12:25,833 --> 00:12:27,433
其他都是 0

413
00:12:27,500 --> 00:12:28,633
就比如说举个例子

414
00:12:28,633 --> 00:12:30,533
就是这个

415
00:12:30,700 --> 00:12:32,300
对角线上有数

416
00:12:32,333 --> 00:12:33,400
那这个时候呢

417
00:12:33,400 --> 00:12:34,433
你会发现呢

418
00:12:34,433 --> 00:12:36,533
我们去真正往里边写数据

419
00:12:36,533 --> 00:12:38,333
或者读它的数据的时候呢

420
00:12:39,066 --> 00:12:40,066
我们会发现呢

421
00:12:40,066 --> 00:12:43,333
这个实际上系统会做一个什么工作呢

422
00:12:43,333 --> 00:12:44,833
就是真正你用的时候

423
00:12:44,833 --> 00:12:47,100
它才会把这个 page 真正的

424
00:12:47,800 --> 00:12:49,566
从物理内存里面分配

425
00:12:49,866 --> 00:12:52,266
比如说我这个时候往这里边写个 1

426
00:12:52,866 --> 00:12:55,800
那我就给它分配一块物理内存

427
00:12:56,066 --> 00:12:57,433
如果我这写个 1

428
00:12:57,433 --> 00:12:59,566
我才给它分配第二块内存啊

429
00:12:59,566 --> 00:13:00,266
这些内存呢

430
00:13:00,266 --> 00:13:01,800
不一定是连续的，对吧

431
00:13:02,000 --> 00:13:04,200
逻辑上虚拟地址是连续的

432
00:13:04,200 --> 00:13:06,300
但是在这里面它不一定是连续的

433
00:13:06,400 --> 00:13:07,700
然后在这啊

434
00:13:07,700 --> 00:13:09,700
在这也就是说它这样的话呢

435
00:13:09,700 --> 00:13:11,600
就是说它可以按需分配

436
00:13:11,600 --> 00:13:12,533
什么叫按需分配

437
00:13:12,533 --> 00:13:14,400
就是说你用到了我才给你分配

438
00:13:14,400 --> 00:13:16,333
真正的物理内存

439
00:13:16,400 --> 00:13:17,466
如果你没用到

440
00:13:17,466 --> 00:13:19,100
那就只是个页表象

441
00:13:19,100 --> 00:13:19,833
只是个页表象

442
00:13:20,100 --> 00:13:20,733
这样子的话呢

443
00:13:20,733 --> 00:13:21,600
虚拟内存技术啊

444
00:13:21,600 --> 00:13:23,900
实际上给我们带来很多很多的好处

445
00:13:23,900 --> 00:13:25,266
我这里边就不多说了

446
00:13:25,266 --> 00:13:26,133
大家可以去看

447
00:13:26,133 --> 00:13:28,933
那个内核的一些实现的书或者代码

448
00:13:28,933 --> 00:13:30,133
它都会有解释

449
00:13:30,333 --> 00:13:32,066
那我们接下来谈一谈

450
00:13:32,066 --> 00:13:34,466
虚拟内存技术带来的坏处是什么

451
00:13:35,333 --> 00:13:36,333
什么叫坏处

452
00:13:36,766 --> 00:13:37,366
对吧

453
00:13:37,733 --> 00:13:38,933
坏处就是说

454
00:13:39,066 --> 00:13:41,366
我这里面实际上已经给出答案了

455
00:13:41,466 --> 00:13:43,333
叫做丧失确定性

456
00:13:43,466 --> 00:13:44,466
我们接下来的话呢

457
00:13:44,466 --> 00:13:46,066
可以跟大家一起探讨一下

458
00:13:46,066 --> 00:13:47,166
什么叫确定性

459
00:13:47,400 --> 00:13:50,133
我这里面所讲的这个确定性

460
00:13:50,333 --> 00:13:51,366
谁能解释一下

461
00:13:51,366 --> 00:13:53,933
为什么虚拟内存技术的引入

462
00:13:54,066 --> 00:13:55,533
实际上给整个系统

463
00:13:55,533 --> 00:13:58,333
带来了一个丧失确定性的坏处

464
00:13:58,333 --> 00:14:00,733
当然这个东西也不一定说是坏处啊

465
00:14:00,866 --> 00:14:03,466
就是那跟实时系统比起来

466
00:14:03,466 --> 00:14:04,633
就 RTOS 比起来

467
00:14:04,633 --> 00:14:08,233
它肯定是没办法达到一个确定性的

468
00:14:08,533 --> 00:14:11,133
那这个确定性表现在什么方面

469
00:14:11,533 --> 00:14:12,933
对，确定性就是可预测

470
00:14:13,466 --> 00:14:16,133
可以准确预估内存使用情况啊

471
00:14:16,133 --> 00:14:17,366
缺页需要时间

472
00:14:17,466 --> 00:14:18,733
内存有没有不知道

473
00:14:18,766 --> 00:14:20,633
需要等到分配的时候才知道

474
00:14:21,233 --> 00:14:22,433
对这些呢

475
00:14:22,433 --> 00:14:23,066
实际上呢

476
00:14:23,066 --> 00:14:25,500
就是基本上就是这么个意思啊

477
00:14:25,500 --> 00:14:26,233
就是这么个意思

478
00:14:26,233 --> 00:14:27,900
虚拟内存技术

479
00:14:27,900 --> 00:14:30,366
它带来了这个确定性的这个丧失

480
00:14:30,533 --> 00:14:32,233
实际上最大的一个特点是什么

481
00:14:32,233 --> 00:14:33,933
就比如说我们分配内存的时候啊

482
00:14:34,033 --> 00:14:36,233
分配实际上返回给你了一个地址

483
00:14:36,233 --> 00:14:37,166
 malloc 也好

484
00:14:37,166 --> 00:14:38,433
或者 mmap 也好

485
00:14:38,433 --> 00:14:39,633
地址给你返回了

486
00:14:39,633 --> 00:14:40,900
但是你真正用的时候

487
00:14:40,900 --> 00:14:42,300
你才知道啊

488
00:14:42,300 --> 00:14:43,300
这个地址呢

489
00:14:43,366 --> 00:14:44,500
根本没法获得啊

490
00:14:44,566 --> 00:14:46,100
那也就是结果是什么呢

491
00:14:46,100 --> 00:14:47,766
就是你在写

492
00:14:47,766 --> 00:14:49,300
就比如说我们刚才这里边

493
00:14:49,666 --> 00:14:50,666
用到这的时候

494
00:14:51,800 --> 00:14:52,800
地址不够了

495
00:14:53,200 --> 00:14:55,266
那内核会去干什么

496
00:14:56,066 --> 00:14:57,266
它会就去捣腾

497
00:14:57,266 --> 00:14:58,233
如果有交换

498
00:14:58,266 --> 00:14:59,533
有交换的这个文件

499
00:14:59,533 --> 00:15:00,433
交换分区

500
00:15:00,500 --> 00:15:02,766
它就是试着去把一些内存

501
00:15:02,766 --> 00:15:03,866
给它释放出来

502
00:15:04,033 --> 00:15:05,966
通过把它放到这个交换文件里

503
00:15:05,966 --> 00:15:06,766
把它释放出来

504
00:15:06,766 --> 00:15:07,200
对吧

505
00:15:07,200 --> 00:15:09,000
那这是会耗时，是不是

506
00:15:09,000 --> 00:15:09,633
首先耗时

507
00:15:09,633 --> 00:15:10,433
如果呢

508
00:15:10,466 --> 00:15:11,700
发现他们的这个内存

509
00:15:11,700 --> 00:15:12,966
交换文件也满了

510
00:15:12,966 --> 00:15:13,633
然后呢

511
00:15:13,633 --> 00:15:15,300
没有更多的物理内存了

512
00:15:15,300 --> 00:15:16,333
这时候怎么办呢

513
00:15:16,500 --> 00:15:17,800
那就只能是报错

514
00:15:17,866 --> 00:15:19,500
这个时候会得到什么错呢

515
00:15:19,500 --> 00:15:21,266
啊就是 segment fault

516
00:15:21,266 --> 00:15:22,733
就是段故障

517
00:15:22,733 --> 00:15:24,233
那个叫段故障

518
00:15:24,300 --> 00:15:24,900
就产生了

519
00:15:24,900 --> 00:15:27,100
实际上就是那个内存真的是不够了

520
00:15:27,100 --> 00:15:29,333
那你的这个进程就会被杀掉

521
00:15:29,333 --> 00:15:30,033
就会被杀掉

522
00:15:30,033 --> 00:15:30,366
对吧

523
00:15:30,366 --> 00:15:31,033
那实际上

524
00:15:31,033 --> 00:15:32,933
它带来的这个不确定性就指什么呢

525
00:15:32,933 --> 00:15:33,433
就是说

526
00:15:33,433 --> 00:15:35,800
如果在 RTOS 上我们分配内存

527
00:15:35,900 --> 00:15:37,200
它就是一个固定的堆

528
00:15:37,300 --> 00:15:38,466
分配到分配不到

529
00:15:38,466 --> 00:15:38,866
对吧

530
00:15:38,866 --> 00:15:39,466
同样的

531
00:15:39,466 --> 00:15:40,866
一个给定的时间之内

532
00:15:40,866 --> 00:15:43,066
它一定是可以得到一个答案

533
00:15:43,433 --> 00:15:45,100
那个 malloc 它会就会返回

534
00:15:45,100 --> 00:15:46,033
什么返回 null

535
00:15:46,366 --> 00:15:47,566
那个函数就会返回 null

536
00:15:47,566 --> 00:15:49,033
但是呢这就叫确定性

537
00:15:49,033 --> 00:15:51,566
如果是在我们的 Linux 这个系统里边

538
00:15:51,866 --> 00:15:53,900
由于虚拟内存技术的存在

539
00:15:54,066 --> 00:15:56,133
它就会产生很多很多

540
00:15:56,133 --> 00:15:58,133
就是本来你内存实际上已经不够了

541
00:15:58,133 --> 00:15:59,966
它返回的值还是有的

542
00:15:59,966 --> 00:16:01,166
但是你真去用的时候

543
00:16:01,166 --> 00:16:03,033
你会发现系统变慢了

544
00:16:03,033 --> 00:16:04,133
变卡了然后呢

545
00:16:04,133 --> 00:16:04,833
倒腾了半天

546
00:16:04,833 --> 00:16:05,833
倒腾倒腾的

547
00:16:05,900 --> 00:16:07,433
可能等个十几分钟之后

548
00:16:07,433 --> 00:16:09,233
告诉你这个进程被杀了

549
00:16:09,300 --> 00:16:12,000
这就是存在的所谓的不确定性

550
00:16:12,000 --> 00:16:14,300
不确定性当然也有很多其它的东西

551
00:16:14,300 --> 00:16:15,800
就比如说 malloc

552
00:16:15,800 --> 00:16:16,600
本来应该是

553
00:16:16,600 --> 00:16:17,733
比如说是 1 毫秒

554
00:16:17,733 --> 00:16:19,133
它就应该返回一个值的

555
00:16:19,133 --> 00:16:19,833
结果呢

556
00:16:19,833 --> 00:16:20,766
快的时候

557
00:16:20,766 --> 00:16:22,033
内存空宽松的时候

558
00:16:22,033 --> 00:16:23,033
它很快就返回了

559
00:16:23,100 --> 00:16:24,233
内存不宽松的时候

560
00:16:24,233 --> 00:16:25,433
它可能很长时间

561
00:16:25,433 --> 00:16:27,200
也有可能特别特别长长时间

562
00:16:27,266 --> 00:16:29,966
甚至它就不能返回一个正确的值

563
00:16:30,066 --> 00:16:30,366
对吧

564
00:16:30,366 --> 00:16:32,000
这些都是确定性的东西

565
00:16:32,000 --> 00:16:32,400
所以呃

566
00:16:32,466 --> 00:16:33,500
确定性的这个

567
00:16:33,833 --> 00:16:35,900
丧失确定性的这个表现形式

568
00:16:35,900 --> 00:16:36,700
那结果

569
00:16:36,700 --> 00:16:38,166
最终的这个结果是什么

570
00:16:38,166 --> 00:16:41,166
就是说它不能像 RTOS 一样

571
00:16:41,166 --> 00:16:42,866
给我们确定性的这个

572
00:16:42,866 --> 00:16:43,966
可以预测的

573
00:16:43,966 --> 00:16:45,666
这么一个程序的执行结果

574
00:16:45,766 --> 00:16:47,300
这就是通用操作系统

575
00:16:47,300 --> 00:16:49,566
和这个 RTOS 之间的最大的区别

576
00:16:49,633 --> 00:16:50,433
那这个东西呢

577
00:16:50,433 --> 00:16:53,600
给我们 C/C++ 的程序编程的时候啊

578
00:16:53,600 --> 00:16:55,033
也会带来一些什么

579
00:16:55,200 --> 00:16:56,100
有好处啊

580
00:16:56,100 --> 00:16:56,966
也有坏处

581
00:16:56,966 --> 00:16:58,766
那我们接下来就分析一下

582
00:16:59,100 --> 00:17:01,266
首先，我们先简单的快速的过一下

583
00:17:01,466 --> 00:17:04,700
C/C++ 程序的这个堆和栈的管理

584
00:17:04,866 --> 00:17:05,100
比如说

585
00:17:05,100 --> 00:17:06,200
我们熟知啊

586
00:17:07,033 --> 00:17:07,633
熟知 C

587
00:17:07,866 --> 00:17:09,900
malloc calloc realloc free

588
00:17:09,900 --> 00:17:10,400
是吧

589
00:17:10,400 --> 00:17:11,966
好，这个大家都懂

590
00:17:11,966 --> 00:17:13,566
但是我现在问一下

591
00:17:14,266 --> 00:17:16,800
calloc 和 malloc 的区别是啥

592
00:17:17,333 --> 00:17:18,133
就是 calloc

593
00:17:18,133 --> 00:17:19,900
它是一定是初始化为 0

594
00:17:19,900 --> 00:17:20,933
就是它这个内存呢

595
00:17:20,933 --> 00:17:22,333
它是初始化为 0 的

596
00:17:22,333 --> 00:17:23,400
而且 calloc 呢

597
00:17:23,400 --> 00:17:24,833
它还有一个特点

598
00:17:24,833 --> 00:17:25,366
还有一个特点

599
00:17:25,366 --> 00:17:27,533
就是说你传的参数是两个

600
00:17:28,100 --> 00:17:29,033
什么叫两个

601
00:17:29,233 --> 00:17:30,600
那其中一个是什么呢

602
00:17:30,600 --> 00:17:31,166
其中一个

603
00:17:31,166 --> 00:17:34,366
是你要分配的单元的那个大小

604
00:17:35,033 --> 00:17:38,366
然后呢才是这个一共有多少个单元

605
00:17:39,000 --> 00:17:41,033
这个和 malloc 是不一样的

606
00:17:41,033 --> 00:17:41,800
malloc 呢

607
00:17:41,800 --> 00:17:42,933
它是什么呢

608
00:17:43,000 --> 00:17:43,966
就是给一个 size

609
00:17:43,966 --> 00:17:45,033
我给你分配过来

610
00:17:45,033 --> 00:17:46,566
那 calloc 呢

611
00:17:46,566 --> 00:17:48,700
它要求你传两个参数

612
00:17:48,700 --> 00:17:50,533
一个是每一个单元

613
00:17:50,533 --> 00:17:51,966
就比说一个结构啊

614
00:17:51,966 --> 00:17:53,000
这个结构大小是多少

615
00:17:53,000 --> 00:17:54,733
然后呢一共你要分配多少

616
00:17:54,733 --> 00:17:56,300
那这里边就会有一个什么

617
00:17:56,300 --> 00:17:57,033
对齐的问题

618
00:17:57,033 --> 00:17:58,300
对齐的一个问题

619
00:17:58,600 --> 00:17:59,433
那 calloc 呢

620
00:17:59,433 --> 00:18:00,933
就是说一

621
00:18:00,933 --> 00:18:02,366
它实际上是经过优化的

622
00:18:02,366 --> 00:18:06,066
我经常看到很多工作了很多年的程序员呢

623
00:18:06,066 --> 00:18:08,866
经常会 malloc 函数调完

624
00:18:08,866 --> 00:18:12,666
然后再把这个内存再用 memset

625
00:18:12,666 --> 00:18:14,700
把它重置成 0

626
00:18:14,766 --> 00:18:15,866
这种代码啊

627
00:18:15,966 --> 00:18:18,666
就算是有工作 10 年甚至 20 年的程序员

628
00:18:18,666 --> 00:18:20,600
我看他也会这么写

629
00:18:21,200 --> 00:18:22,400
大家不要这么去写

630
00:18:22,400 --> 00:18:24,233
那应该用什么？calloc

631
00:18:24,233 --> 00:18:27,966
因为 calloc 它本身就会把这个内存给清空

632
00:18:27,966 --> 00:18:28,800
所以的话呢

633
00:18:28,800 --> 00:18:30,400
那个一定是最优的

634
00:18:30,433 --> 00:18:32,766
你如果先 malloc

635
00:18:32,766 --> 00:18:33,766
然后再 memset

636
00:18:33,766 --> 00:18:34,533
那个就不对

637
00:18:34,566 --> 00:18:35,400
就不正确

638
00:18:35,733 --> 00:18:36,566
那另外一个呢

639
00:18:36,566 --> 00:18:37,700
就是 realloc

640
00:18:38,033 --> 00:18:39,700
realloc 大家都知道吧

641
00:18:39,700 --> 00:18:41,400
就是我给你一块地址

642
00:18:41,400 --> 00:18:43,800
然后我要改变这块地址的大小

643
00:18:44,000 --> 00:18:46,633
你再帮我重新的分配一下

644
00:18:46,733 --> 00:18:47,266
这个时候呢

645
00:18:47,266 --> 00:18:48,666
它有什么好处嘞

646
00:18:48,666 --> 00:18:51,866
就是里边的内容如果原先就有

647
00:18:51,866 --> 00:18:53,433
比如说我是要把它变长

648
00:18:53,533 --> 00:18:54,433
那这个时候呢

649
00:18:54,833 --> 00:18:55,966
重新分配之后

650
00:18:56,266 --> 00:18:58,133
新拿到这个地址啊

651
00:18:58,366 --> 00:19:00,766
它会把原来那个内存呢

652
00:19:00,766 --> 00:19:02,266
给拷贝过来

653
00:19:02,400 --> 00:19:04,833
但是大家一定要注意啊

654
00:19:04,833 --> 00:19:05,800
一定要注意

655
00:19:05,933 --> 00:19:07,400
我给大家举个例子

656
00:19:07,533 --> 00:19:11,066
realloc 它实质上也是经过优化的

657
00:19:11,066 --> 00:19:12,633
而且它的这个行为啊

658
00:19:12,633 --> 00:19:15,400
是跟那个堆的这个算法是有关系的

659
00:19:15,600 --> 00:19:16,466
那有的时候呢

660
00:19:16,466 --> 00:19:17,866
比如说我用这个

661
00:19:18,266 --> 00:19:29,700
char* P = strdup("ABC");

662
00:19:30,700 --> 00:19:32,366
然后我现在呢

663
00:19:32,366 --> 00:19:33,633
得到了一个 P

664
00:19:33,833 --> 00:19:35,500
然后呢我我现在要干什么呢

665
00:19:35,500 --> 00:19:39,066
我要把这个内存再 realloc 一下

666
00:19:42,000 --> 00:19:42,366
P

667
00:19:42,366 --> 00:19:43,466
然后呢

668
00:19:43,566 --> 00:19:44,100
比如说啊

669
00:19:44,100 --> 00:19:46,533
我要后面再加几个东西嘛

670
00:19:46,633 --> 00:19:48,900
比如说是 ABC123

671
00:19:49,100 --> 00:19:51,066
那它就得至少是 7 个

672
00:19:51,066 --> 00:19:53,033
我就简单写 7 了

673
00:19:53,300 --> 00:19:54,500
那这个时候

674
00:19:55,266 --> 00:19:57,000
大概率这个

675
00:19:58,033 --> 00:20:00,900
我把它再设一个 P1 吧

676
00:20:00,900 --> 00:20:04,433
大概率 P1 和这个 P 是相等的

677
00:20:05,000 --> 00:20:05,800
大概率

678
00:20:10,100 --> 00:20:11,400
大家一定要注意啊

679
00:20:11,400 --> 00:20:13,700
就是说大部分情况之下

680
00:20:13,700 --> 00:20:15,100
像这种用法啊

681
00:20:15,100 --> 00:20:17,100
就比如说我就分配了三个字节

682
00:20:17,266 --> 00:20:19,266
但实际上应该是 4 个字节啊

683
00:20:19,400 --> 00:20:21,700
因为这个里边还有后面还有 \0 嘛

684
00:20:21,700 --> 00:20:22,500
对吧，字符串

685
00:20:22,933 --> 00:20:23,866
然后呢 realloc

686
00:20:23,866 --> 00:20:26,433
我把它扩大成 7 的这个长度

687
00:20:26,600 --> 00:20:29,333
那大概率 P1 就等于 P

688
00:20:29,666 --> 00:20:30,300
大概率啊

689
00:20:30,300 --> 00:20:32,466
大家可以自己去试着去写一下

690
00:20:32,466 --> 00:20:34,266
课后自己去试一试

691
00:20:34,366 --> 00:20:35,900
那为什么会出现这种情况

692
00:20:36,033 --> 00:20:37,233
哪位同学说一下

693
00:20:37,233 --> 00:20:39,533
申请内存有个最小分配单元

694
00:20:39,533 --> 00:20:40,800
这句话是答对了

695
00:20:40,866 --> 00:20:41,400
也就是说

696
00:20:41,400 --> 00:20:41,866
实质上

697
00:20:41,866 --> 00:20:44,566
我们待会会分析一个堆的

698
00:20:44,566 --> 00:20:46,000
基本的一个算法

699
00:20:46,000 --> 00:20:47,000
堆的分配算法的时候

700
00:20:47,000 --> 00:20:47,866
你就会知道

701
00:20:48,000 --> 00:20:48,833
有的时候啊

702
00:20:48,833 --> 00:20:49,933
就这个分配啊

703
00:20:49,933 --> 00:20:51,766
不是说你分配 4 个字节

704
00:20:51,766 --> 00:20:53,400
我一定就给你 4 个字节

705
00:20:53,400 --> 00:20:54,500
那是不可能的

706
00:20:54,500 --> 00:20:55,600
没有这么干的

707
00:20:56,033 --> 00:20:57,233
它通常就会有一个

708
00:20:57,233 --> 00:20:59,166
最小的一个分配单元

709
00:20:59,166 --> 00:21:00,733
这个跟那个磁盘上

710
00:21:00,733 --> 00:21:01,933
大家磁盘都知道吧

711
00:21:01,933 --> 00:21:04,200
磁盘上分配文件的时候也是

712
00:21:04,200 --> 00:21:05,600
最小也得有个分配单元

713
00:21:05,600 --> 00:21:08,133
你不可能按字节为单位分配，对吧

714
00:21:08,433 --> 00:21:08,933
那样的话

715
00:21:08,933 --> 00:21:12,566
你管理的成本就会非常非常高

716
00:21:12,566 --> 00:21:14,966
所以申请内存它有个最小分配单元

717
00:21:15,166 --> 00:21:15,666
什么意思呢

718
00:21:15,666 --> 00:21:18,333
你比如说你分配 4 个字节在这里边

719
00:21:18,566 --> 00:21:20,566
那我们实质上得到的东西呢

720
00:21:20,566 --> 00:21:21,933
它就可能就是 8 个字节

721
00:21:21,933 --> 00:21:23,866
或者是 16 个字节啊

722
00:21:24,233 --> 00:21:26,533
大概率应该是 8 个字节

723
00:21:26,600 --> 00:21:27,333
然后呢

724
00:21:27,333 --> 00:21:30,200
我在这里面把它扩大成 7 个字节

725
00:21:30,533 --> 00:21:32,100
那不是还是在 8 里面吗

726
00:21:32,433 --> 00:21:34,333
那我直接就把这个东西返回给你了

727
00:21:34,333 --> 00:21:36,033
我干嘛再去倒腾一遍呢

728
00:21:36,333 --> 00:21:36,600
对吧

729
00:21:36,666 --> 00:21:37,133
所以呢

730
00:21:37,133 --> 00:21:37,933
这个时候呢

731
00:21:37,933 --> 00:21:39,133
P1 就等于 P

732
00:21:39,133 --> 00:21:40,166
大概率

733
00:21:40,300 --> 00:21:42,733
当然这个呢不是说永远是真实的

734
00:21:42,733 --> 00:21:44,900
是因为它跟底层的这个

735
00:21:44,933 --> 00:21:47,166
我们的这个堆的管理算法是有关系的

736
00:21:47,166 --> 00:21:49,200
所以我在这里面写了一个大概率

737
00:21:49,200 --> 00:21:49,600
大概率

738
00:21:49,600 --> 00:21:51,300
这个就是说考验一下

739
00:21:51,300 --> 00:21:54,933
大家对堆的算法的一个了解程度

740
00:21:54,933 --> 00:21:57,866
发现你看大家还是有很多人没明白

741
00:21:57,866 --> 00:21:59,366
为什么会出现这种情况

742
00:21:59,733 --> 00:22:01,766
好，那 malloc/calloc/realloc/free

743
00:22:01,766 --> 00:22:03,366
这个东西呢我们就过了

744
00:22:03,366 --> 00:22:05,466
因为大家都是就经常用的

745
00:22:05,466 --> 00:22:05,766
但是呢

746
00:22:05,766 --> 00:22:08,966
我也指出了可能一些细节上的

747
00:22:08,966 --> 00:22:10,766
你不清楚的一些东西

748
00:22:10,966 --> 00:22:13,133
然后呢 C++ 当然大家都知道啊

749
00:22:13,133 --> 00:22:15,266
就是 new/delete 嘛

750
00:22:15,966 --> 00:22:17,733
这个就没啥好说的

751
00:22:18,200 --> 00:22:19,566
然后我们不熟悉的啊

752
00:22:19,933 --> 00:22:21,866
这里面我给大家列了一些

753
00:22:21,866 --> 00:22:23,500
我们可能不太常用的

754
00:22:23,500 --> 00:22:25,733
一些分配内存的

755
00:22:25,733 --> 00:22:27,400
注意啊，我这里面讲的内存呢

756
00:22:27,400 --> 00:22:29,766
包括了堆也包括了栈，是吧

757
00:22:29,766 --> 00:22:30,333
那所以呢

758
00:22:30,333 --> 00:22:32,000
我第一个给大家的是什么呢

759
00:22:32,000 --> 00:22:36,966
就是 alloca这个函数

760
00:22:37,400 --> 00:22:38,600
那这个函数啊

761
00:22:38,600 --> 00:22:40,366
它实际上是一个 GCC 的扩展

762
00:22:40,366 --> 00:22:40,866
它是什么呢

763
00:22:40,866 --> 00:22:43,300
就是在栈里边分配内存

764
00:22:43,300 --> 00:22:45,066
实际上就是在当前的栈帧

765
00:22:45,100 --> 00:22:45,800
也就是说

766
00:22:45,800 --> 00:22:47,000
我们都知道啊

767
00:22:47,166 --> 00:22:48,366
C 的这个程序呢

768
00:22:48,366 --> 00:22:49,600
它是什么呢？栈

769
00:22:49,600 --> 00:22:50,766
对吧

770
00:22:51,000 --> 00:22:51,800
栈

771
00:22:52,933 --> 00:22:53,733
栈

772
00:22:54,100 --> 00:22:55,900
栈呢是往下走的

773
00:22:55,900 --> 00:22:58,966
然后是先进后出，是吧

774
00:22:59,033 --> 00:23:00,733
然后我先压一个

775
00:23:00,733 --> 00:23:02,633
push 一个什么东西啊

776
00:23:02,733 --> 00:23:06,233
这个叫做 Stack Frame

777
00:23:06,366 --> 00:23:07,333
栈帧

778
00:23:07,333 --> 00:23:08,633
中文叫栈帧

779
00:23:08,633 --> 00:23:10,533
就是一个栈帧

780
00:23:10,966 --> 00:23:13,766
一个函数调用就会压一个栈帧进去

781
00:23:13,766 --> 00:23:14,033
对吧

782
00:23:14,033 --> 00:23:15,266
这个函数返回的时候

783
00:23:15,266 --> 00:23:16,033
这个栈帧呢

784
00:23:16,033 --> 00:23:17,966
就会被 pop 出去

785
00:23:18,466 --> 00:23:19,500
pop 出去，对吧

786
00:23:19,533 --> 00:23:20,933
它就是再回去

787
00:23:21,133 --> 00:23:22,366
就是这样往下走

788
00:23:22,366 --> 00:23:23,566
然后呢再回去

789
00:23:23,633 --> 00:23:24,733
它就是这样子的一个

790
00:23:24,733 --> 00:23:26,933
就是说是先进后出的

791
00:23:26,933 --> 00:23:28,433
这么一个栈的一个结构

792
00:23:28,433 --> 00:23:29,500
那栈的结构呢

793
00:23:29,500 --> 00:23:30,366
这个栈帧啊

794
00:23:30,366 --> 00:23:32,266
就当前这个函数的栈帧

795
00:23:32,266 --> 00:23:34,466
是可以发生变化的

796
00:23:34,466 --> 00:23:37,333
就是它的长度是可以发生变化的

797
00:23:37,666 --> 00:23:38,966
这个大家一定要注意

798
00:23:39,100 --> 00:23:39,700
所以的话呢

799
00:23:39,700 --> 00:23:41,500
我们才会有 alloca

800
00:23:41,500 --> 00:23:43,566
那 alloca 这个函数呢

801
00:23:43,566 --> 00:23:46,400
是一个 Linux GCC 特有的

802
00:23:46,400 --> 00:23:47,566
它在不同的架构上

803
00:23:47,566 --> 00:23:49,166
可能会有不同的实现

804
00:23:49,366 --> 00:23:50,300
有人说啊

805
00:23:50,300 --> 00:23:53,800
在 ARMCC 就 ARM 自己做的那个 C 编译器里面

806
00:23:54,033 --> 00:23:56,033
alloca 实际上是 malloc

807
00:23:56,266 --> 00:23:59,633
只不过变异器帮你在函数返回的时候

808
00:23:59,633 --> 00:24:00,600
释放了而已

809
00:24:00,633 --> 00:24:02,433
这个可能性是有的

810
00:24:02,433 --> 00:24:03,666
但是今天这个实现呢

811
00:24:03,666 --> 00:24:06,266
它是通过扩展当前的栈帧

812
00:24:06,266 --> 00:24:07,466
就是最新的那个

813
00:24:07,500 --> 00:24:09,100
最底下的那个栈帧

814
00:24:09,100 --> 00:24:10,866
以前那个栈帧是没法再改了

815
00:24:10,866 --> 00:24:12,566
但是最底下那个站着

816
00:24:12,566 --> 00:24:14,200
就是当前你函数调用的站着

817
00:24:14,200 --> 00:24:15,433
是 OK 了，对吧

818
00:24:15,500 --> 00:24:18,333
还有一个就是 VLA

819
00:24:18,533 --> 00:24:19,866
VLA 是什么呢

820
00:24:20,033 --> 00:24:21,900
是 Variable Length Array

821
00:24:21,900 --> 00:24:22,466
什么意思呢

822
00:24:22,466 --> 00:24:24,433
就是变长数组

823
00:24:24,433 --> 00:24:25,233
变长数组

824
00:24:25,266 --> 00:24:27,100
就比如说我们在一个函数里边

825
00:24:29,700 --> 00:24:32,566
void fun(void)

826
00:24:33,266 --> 00:24:34,200
这个函数里面呢

827
00:24:34,200 --> 00:24:36,100
我们可以分配一个什么呢

828
00:24:36,100 --> 00:24:38,900
char 比如说是 str[ ]

829
00:24:40,000 --> 00:24:41,333
这样子

830
00:24:41,533 --> 00:24:42,366
然后这里边呢

831
00:24:42,366 --> 00:24:43,800
你给它传一个参数

832
00:24:44,300 --> 00:24:45,333
比如说 (int a)

833
00:24:46,966 --> 00:24:47,766
[a]

834
00:24:49,233 --> 00:24:53,700
这是 C99 的规范

835
00:24:53,700 --> 00:24:54,466
C99 呢

836
00:24:54,466 --> 00:24:56,100
也是支持这种方式的

837
00:24:56,100 --> 00:24:57,466
就是这个 a 呀

838
00:24:57,866 --> 00:24:59,266
它传过来是个变量嘛

839
00:24:59,266 --> 00:24:59,666
对吧

840
00:24:59,666 --> 00:25:01,200
那比如说是 10

841
00:25:01,200 --> 00:25:02,266
它就分配 10

842
00:25:02,400 --> 00:25:04,566
如果是 11 它就分配 11

843
00:25:04,600 --> 00:25:05,566
是不是

844
00:25:05,566 --> 00:25:07,100
这样子的一个方式

845
00:25:07,166 --> 00:25:09,100
那这个就叫做 VLA

846
00:25:09,466 --> 00:25:10,300
VLA 呢

847
00:25:10,300 --> 00:25:12,533
实际上也给我们带来很多好处

848
00:25:13,166 --> 00:25:15,333
如果你确保这个 a 呀

849
00:25:15,333 --> 00:25:16,366
不是特别大

850
00:25:16,366 --> 00:25:17,533
比如说你一下子比

851
00:25:17,533 --> 00:25:18,800
别一下子分配多少

852
00:25:18,800 --> 00:25:20,333
就比如说是

853
00:25:20,333 --> 00:25:21,800
1M 什么之类的

854
00:25:21,800 --> 00:25:22,866
因为 1M 的时候呢

855
00:25:22,866 --> 00:25:24,433
你这个栈太大了

856
00:25:24,433 --> 00:25:26,366
一下子这个分配的栈太大

857
00:25:26,600 --> 00:25:29,333
而且如果是函数嵌套

858
00:25:29,333 --> 00:25:31,333
尤其是被递归的这种情况之下

859
00:25:31,333 --> 00:25:35,033
那你这个函数就有可能把栈给撑爆

860
00:25:35,033 --> 00:25:35,366
对吧

861
00:25:35,366 --> 00:25:35,866
所以呢

862
00:25:35,866 --> 00:25:37,966
我们要防止这种情况的出现

863
00:25:38,033 --> 00:25:40,333
那如果这个 a 是比较确定性的

864
00:25:40,333 --> 00:25:42,266
那相对来讲比较小，是吧

865
00:25:42,266 --> 00:25:43,266
比较小

866
00:25:43,366 --> 00:25:45,400
或者是它有最大值的这个限制

867
00:25:45,466 --> 00:25:49,400
那我们就可以用 VLA 这种方式去分配内存

868
00:25:49,500 --> 00:25:50,500
那这个东西呢

869
00:25:50,500 --> 00:25:51,933
我给大家举个例子

870
00:25:52,233 --> 00:25:53,633
我们以前的时候啊

871
00:25:54,000 --> 00:25:57,200
就没有 C99 的 VLA 这个东西的时候呢

872
00:25:57,266 --> 00:25:57,733
实际上

873
00:25:57,733 --> 00:26:02,200
我们如果要处理文件的路径的时候

874
00:26:02,266 --> 00:26:03,400
有的时候挺讨厌的

875
00:26:03,666 --> 00:26:04,533
文件路径

876
00:26:08,000 --> 00:26:08,800
对吧

877
00:26:09,033 --> 00:26:11,966
大家都知道 Linux 系统里边有一个

878
00:26:14,033 --> 00:26:16,666
MAX_PATH 的这么一个宏

879
00:26:17,000 --> 00:26:17,800
是吧

880
00:26:18,400 --> 00:26:19,466
MAX_PATH

881
00:26:19,466 --> 00:26:22,000
这个 MAX_PATH 这个宏是干什么呢

882
00:26:22,000 --> 00:26:26,200
就是定义这个系统能支持的最大的路径的长度

883
00:26:26,333 --> 00:26:27,833
这个通常呢是什么呢

884
00:26:28,166 --> 00:26:29,866
大概是 1024

885
00:26:29,866 --> 00:26:30,933
一般是 1023

886
00:26:30,933 --> 00:26:31,333
因为

887
00:26:31,333 --> 00:26:34,600
后面再给你放个 \0 的那个东西

888
00:26:34,600 --> 00:26:36,066
或者是 511

889
00:26:36,566 --> 00:26:37,633
但是这个东西呢

890
00:26:37,633 --> 00:26:39,400
它有一个什么讨厌的地方呢

891
00:26:39,400 --> 00:26:39,900
就是说

892
00:26:40,000 --> 00:26:42,900
通常我们的文件路径不会那么长，对吧

893
00:26:43,300 --> 00:26:45,433
那我没必要每次分配的时候

894
00:26:45,433 --> 00:26:46,366
处理文件的时候呢

895
00:26:46,366 --> 00:26:47,700
我就分配这么长

896
00:26:47,700 --> 00:26:48,800
1024 对吧

897
00:26:48,800 --> 00:26:51,200
1023 再加上一个 \0 那不就 1024

898
00:26:51,200 --> 00:26:52,300
不就 1K 了，对吧

899
00:26:52,300 --> 00:26:54,800
如果你刚好要倒腾一下多个文件

900
00:26:54,800 --> 00:26:57,533
那你就一下子要分配很多内存出去

901
00:26:57,533 --> 00:26:57,733
是吧

902
00:26:58,133 --> 00:26:59,600
那这种东西呢就很讨厌

903
00:26:59,600 --> 00:27:02,300
1K、2K 的你去分配这个内存，是吧

904
00:27:02,300 --> 00:27:03,233
就会很讨厌

905
00:27:03,333 --> 00:27:05,100
那像这种情况之下

906
00:27:05,100 --> 00:27:05,833
我们怎么做呢

907
00:27:06,100 --> 00:27:07,233
如果你刚好知道

908
00:27:07,233 --> 00:27:09,666
比如说我现在要把一个路径

909
00:27:14,566 --> 00:27:15,066
parent

910
00:27:15,066 --> 00:27:16,466
我传了两个参数

911
00:27:16,466 --> 00:27:19,000
const char* parent

912
00:27:19,266 --> 00:27:20,866
然后呢我又传了一个

913
00:27:20,866 --> 00:27:25,800
const char* fname

914
00:27:28,033 --> 00:27:28,966
两个参数

915
00:27:29,033 --> 00:27:30,666
然后我在这个函数里干嘛呢

916
00:27:30,666 --> 00:27:31,833
我要打开它

917
00:27:31,966 --> 00:27:33,166
比如说是 fopen

918
00:27:35,266 --> 00:27:35,733
是吧

919
00:27:35,733 --> 00:27:37,433
如果没有 VLA

920
00:27:37,433 --> 00:27:39,666
或者 alloca 这样的函数的话

921
00:27:39,666 --> 00:27:42,333
我们要把这两个要串起来吧

922
00:27:42,866 --> 00:27:43,966
串起来然后呢

923
00:27:43,966 --> 00:27:45,633
我又不知道它的大小是多少

924
00:27:45,733 --> 00:27:47,166
那笨的办法呢

925
00:27:47,166 --> 00:27:48,766
就是说我干脆是吧

926
00:27:49,266 --> 00:27:53,033
就是 char full_path

927
00:27:54,800 --> 00:27:55,966
这个函数呢

928
00:27:55,966 --> 00:27:57,433
就是再加上 MAX 那个

929
00:27:57,433 --> 00:27:59,266
就刚才那  MAX_PATH 加一

930
00:27:59,266 --> 00:27:59,533
对吧

931
00:27:59,533 --> 00:28:00,600
我是干脆直接分配

932
00:28:00,600 --> 00:28:04,066
在栈里面分配这么大的一个东西，是吧

933
00:28:04,266 --> 00:28:06,100
然后我再 strcat

934
00:28:06,100 --> 00:28:08,133
它们的这个就 full_path 出来了

935
00:28:08,133 --> 00:28:08,933
对吧

936
00:28:09,566 --> 00:28:10,666
这是一种办法

937
00:28:10,733 --> 00:28:12,200
那还有一种办法什么呢

938
00:28:12,200 --> 00:28:14,533
就是利用这个VLA

939
00:28:14,700 --> 00:28:16,433
那 VLA 怎么利用呢

940
00:28:16,433 --> 00:28:16,866
对吧

941
00:28:16,866 --> 00:28:18,033
我首先这个

942
00:28:18,433 --> 00:28:20,800
我就这个 full_path

943
00:28:22,533 --> 00:28:24,533
那这个括号里面是什么东西呢

944
00:28:24,533 --> 00:28:25,233
对吧

945
00:28:26,866 --> 00:28:27,966
我就可以用这个了

946
00:28:28,100 --> 00:28:31,766
strlen (parent)，对吧

947
00:28:31,766 --> 00:28:34,833
再加上一个 fname

948
00:28:40,266 --> 00:28:43,400
也是 strlen (fname)

949
00:28:45,566 --> 00:28:46,000
呃

950
00:28:46,000 --> 00:28:47,200
大家一定要注意啊

951
00:28:47,533 --> 00:28:48,800
这里面还得加个东西

952
00:28:48,866 --> 00:28:49,500
谁来回答一下

953
00:28:49,500 --> 00:28:50,466
我应该加几

954
00:28:50,466 --> 00:28:51,933
加 1，加 2，还是加 3

955
00:28:52,066 --> 00:28:53,466
这个必须得加 2

956
00:28:54,566 --> 00:28:55,366
为啥

957
00:28:56,533 --> 00:28:58,366
为啥？parent 那一般给的是

958
00:28:58,366 --> 00:28:59,866
比如说是 home 是吧

959
00:29:00,700 --> 00:29:02,633
那不还得有一个斜杠嘛

960
00:29:03,100 --> 00:29:04,866
你要确保后面还得有一个斜杠

961
00:29:04,866 --> 00:29:06,700
这个斜杠多了没关系

962
00:29:06,700 --> 00:29:08,300
如果你组成这个 full_path

963
00:29:08,300 --> 00:29:09,466
里面多了没关系

964
00:29:09,866 --> 00:29:11,266
但是你不能少啊

965
00:29:12,066 --> 00:29:12,866
对不对

966
00:29:12,866 --> 00:29:14,900
所以呢，要加个 2

967
00:29:15,433 --> 00:29:16,033
也就是说

968
00:29:16,033 --> 00:29:18,166
我们将来 strcat 的时候

969
00:29:18,166 --> 00:29:20,133
先拷贝 full_path 里面

970
00:29:20,133 --> 00:29:21,466
把这个 parent 拷贝过去

971
00:29:21,466 --> 00:29:23,566
然后再 strcat  一个什么？斜杠

972
00:29:24,766 --> 00:29:27,333
然后再 strcat 开了个什么 fname

973
00:29:27,333 --> 00:29:28,933
所以呢这有加 2

974
00:29:28,933 --> 00:29:31,066
你看我们就给大家经常的

975
00:29:31,066 --> 00:29:33,833
就是搞点这个小陷阱

976
00:29:34,200 --> 00:29:35,133
好我们再往下看啊

977
00:29:35,133 --> 00:29:38,366
就是 posix_memalign/aligned_alloc

978
00:29:38,566 --> 00:29:39,333
这两个函数呢

979
00:29:39,333 --> 00:29:40,633
实际上

980
00:29:40,633 --> 00:29:42,933
大家呢用的可能比较少

981
00:29:42,933 --> 00:29:44,800
这个一看就知道了

982
00:29:44,800 --> 00:29:46,966
它前面带了 aligned 

983
00:29:46,966 --> 00:29:47,433
指什么呢

984
00:29:47,433 --> 00:29:49,600
就说我对齐分配

985
00:29:49,600 --> 00:29:50,800
什么叫对齐分配啊

986
00:29:51,066 --> 00:29:51,833
通常比如说

987
00:29:51,833 --> 00:29:55,466
我们以 posix_memalign 这个函数

988
00:29:55,600 --> 00:29:57,266
为圆形去看的话啊

989
00:29:57,466 --> 00:29:58,266
那这个函数呢

990
00:29:58,266 --> 00:30:00,266
它的这个参数是两个

991
00:30:00,266 --> 00:30:04,366
跟那个 calloc 很像

992
00:30:04,433 --> 00:30:04,700
很像

993
00:30:04,700 --> 00:30:06,533
calloc 不是两个参数吗

994
00:30:06,733 --> 00:30:08,100
一个是 nr

995
00:30:08,100 --> 00:30:09,133
一个是size

996
00:30:09,133 --> 00:30:11,500
对吧就是说你每一个是多少

997
00:30:11,500 --> 00:30:13,033
然后一共要分配多少

998
00:30:13,266 --> 00:30:16,466
然后 posix 这个也一样啊

999
00:30:17,200 --> 00:30:17,933
这个函数呢

1000
00:30:17,933 --> 00:30:19,533
实际上我们用的少

1001
00:30:19,533 --> 00:30:20,666
用的少是因为什么呢

1002
00:30:20,666 --> 00:30:21,666
malloc 这个函数

1003
00:30:21,666 --> 00:30:25,466
它基本上会把这个单元

1004
00:30:25,466 --> 00:30:27,733
就基本上会按照这个最低的

1005
00:30:27,733 --> 00:30:28,533
比如说 32 位

1006
00:30:28,533 --> 00:30:29,600
那就 4 字节对齐

1007
00:30:29,600 --> 00:30:30,966
64 位就是 8 字节对齐

1008
00:30:30,966 --> 00:30:32,566
它基本上都会那么样对齐

1009
00:30:32,666 --> 00:30:33,666
但是有的时候

1010
00:30:33,666 --> 00:30:36,000
我们要特别的去把它对齐一下

1011
00:30:36,000 --> 00:30:36,933
举个例子

1012
00:30:36,933 --> 00:30:39,566
就是你系统里面

1013
00:30:39,666 --> 00:30:41,866
同时有一个 32 位的进程

1014
00:30:41,866 --> 00:30:43,466
和 64 位的进程在跑

1015
00:30:43,566 --> 00:30:44,666
32 位的进程呢

1016
00:30:44,666 --> 00:30:45,900
它是 4 字节对齐的

1017
00:30:45,900 --> 00:30:47,266
但是 64 位的进程呢

1018
00:30:47,266 --> 00:30:48,766
默认是 8 字节对齐的

1019
00:30:48,766 --> 00:30:49,433
那这个时候呢

1020
00:30:49,433 --> 00:30:52,466
我希望就是它用最高的那个去对齐

1021
00:30:52,466 --> 00:30:53,733
那好，我们也该怎么样

1022
00:30:53,733 --> 00:30:55,466
posix_memalign 对吧

1023
00:30:55,466 --> 00:30:59,033
用这个函数去确定性的告诉它说

1024
00:30:59,033 --> 00:31:01,933
我希望以什么为单位去对齐

1025
00:31:01,933 --> 00:31:02,966
当然这个参数啊

1026
00:31:03,066 --> 00:31:04,133
就对齐的这个

1027
00:31:04,133 --> 00:31:04,933
这个

1028
00:31:06,233 --> 00:31:07,233
align 这个东西呢

1029
00:31:07,233 --> 00:31:09,500
它一定是 2 的次方

1030
00:31:09,500 --> 00:31:10,166
2 的幂

1031
00:31:10,300 --> 00:31:11,833
然后再往下

1032
00:31:11,833 --> 00:31:12,700
再往下这个函数呢

1033
00:31:12,700 --> 00:31:14,266
就是 brk/sbrk

1034
00:31:14,400 --> 00:31:16,033
这个是一个系统调用

1035
00:31:16,033 --> 00:31:16,933
这个系统调用

1036
00:31:17,233 --> 00:31:20,366
这个基本上应用程序是不会去调

1037
00:31:21,366 --> 00:31:22,433
不会去调

1038
00:31:22,666 --> 00:31:24,966
它用来干什么

1039
00:31:25,766 --> 00:31:29,266
然后呢还有底下的 etext/edata/end

1040
00:31:29,566 --> 00:31:34,033
这几个东西是 C 程序的全局变量

1041
00:31:34,033 --> 00:31:34,833
全局变量

1042
00:31:34,900 --> 00:31:36,166
这个全局变量呢

1043
00:31:36,466 --> 00:31:38,466
也是有一些特殊的含义的

1044
00:31:38,566 --> 00:31:41,566
那我们接下来就给大家讲讲这个东西是怎么弄的

1045
00:31:41,566 --> 00:31:42,133
这个东西呢

1046
00:31:42,133 --> 00:31:44,166
实质上就涉及到什么呢

1047
00:31:44,166 --> 00:31:47,600
C/C++ 进程的内存布局的这个问题

1048
00:31:47,833 --> 00:31:48,666
内存布局

1049
00:31:48,666 --> 00:31:50,266
可能大家了解的话

1050
00:31:50,266 --> 00:31:51,466
基本上就是这样子的

1051
00:31:51,933 --> 00:31:53,400
看基本上就是这样子的

1052
00:31:53,400 --> 00:31:54,233
它是一个

1053
00:31:55,500 --> 00:31:57,266
不是一个虚拟地址空间吗

1054
00:31:57,266 --> 00:31:58,500
我们再往下看

1055
00:31:58,500 --> 00:31:59,500
这里面有个图

1056
00:31:59,900 --> 00:32:00,666
这个图呢

1057
00:32:00,666 --> 00:32:02,400
就是说最底下呢

1058
00:32:02,400 --> 00:32:04,133
它实际上有个 reserve

1059
00:32:05,266 --> 00:32:07,000
reserve 的这么一个

1060
00:32:07,033 --> 00:32:08,466
大概应该是一个页吧

1061
00:32:08,466 --> 00:32:11,133
一个页就是 4K 的这么空间的

1062
00:32:11,133 --> 00:32:12,233
它是 reserve

1063
00:32:12,233 --> 00:32:12,833
也就是说

1064
00:32:12,833 --> 00:32:13,366
实际上

1065
00:32:13,366 --> 00:32:16,200
我们不是经常访问那个空地址的时候

1066
00:32:16,200 --> 00:32:17,000
就会出错吗

1067
00:32:17,000 --> 00:32:18,700
就是通过它来弄的

1068
00:32:18,700 --> 00:32:20,000
这个虚拟地址

1069
00:32:20,266 --> 00:32:24,266
它对应的那个页表像是没有的

1070
00:32:24,700 --> 00:32:25,000
对吧

1071
00:32:25,000 --> 00:32:26,900
虚拟地址这个东西是存在

1072
00:32:26,900 --> 00:32:28,633
但是它对应的页表项是没有的

1073
00:32:28,800 --> 00:32:30,466
然后再往上是什么啊

1074
00:32:30,466 --> 00:32:31,800
叫 Text 段

1075
00:32:32,366 --> 00:32:33,166
对吧

1076
00:32:33,300 --> 00:32:34,866
然后再往上是什么呢

1077
00:32:36,233 --> 00:32:38,966
叫做初始化的

1078
00:32:38,966 --> 00:32:40,100
就是 Data 段

1079
00:32:40,100 --> 00:32:44,000
我们就看那个 PPT 上那个图

1080
00:32:44,000 --> 00:32:44,700
Data 段

1081
00:32:44,900 --> 00:32:46,833
然后再往上是什么呢

1082
00:32:48,200 --> 00:32:50,166
叫 BSS 段

1083
00:32:50,166 --> 00:32:51,700
未初始化的

1084
00:32:51,700 --> 00:32:53,400
就是未初始化的这个数据段

1085
00:32:53,400 --> 00:32:55,033
也叫 BSS 段

1086
00:32:55,300 --> 00:32:56,666
我们再往上看

1087
00:32:56,666 --> 00:32:59,500
这个就叫做 heap

1088
00:32:59,966 --> 00:33:01,666
然后再往上呢

1089
00:33:01,666 --> 00:33:02,666
这是 Stack

1090
00:33:03,033 --> 00:33:04,700
这是栈

1091
00:33:04,700 --> 00:33:05,600
然后中间呢

1092
00:33:05,600 --> 00:33:06,900
有一些区域啊

1093
00:33:06,900 --> 00:33:08,200
这些区域不联系

1094
00:33:08,200 --> 00:33:09,200
我就点点点

1095
00:33:09,300 --> 00:33:09,833
那这个呢

1096
00:33:09,833 --> 00:33:11,066
就是 mmap 出来的

1097
00:33:11,100 --> 00:33:13,366
就是你调 mmap 对吧

1098
00:33:13,366 --> 00:33:14,433
匿名 mmap

1099
00:33:14,433 --> 00:33:15,566
待会我会讲到

1100
00:33:15,666 --> 00:33:18,233
匿名 mmap 它的这个虚拟地址呢

1101
00:33:18,233 --> 00:33:19,666
通常在这个区域里面

1102
00:33:19,900 --> 00:33:21,400
然后是栈，栈这个东西呢

1103
00:33:21,400 --> 00:33:23,200
往下增长，对吧

1104
00:33:23,200 --> 00:33:25,600
随着这个函数的调用，对吧

1105
00:33:25,600 --> 00:33:27,066
如果嵌套的这个特别深

1106
00:33:27,066 --> 00:33:28,066
就会往下走

1107
00:33:28,233 --> 00:33:29,800
然后 heap 呢是往上

1108
00:33:29,800 --> 00:33:30,733
什么叫 heap 是往上

1109
00:33:30,733 --> 00:33:31,666
就初始的时候

1110
00:33:31,666 --> 00:33:32,633
这个进程啊

1111
00:33:32,700 --> 00:33:33,866
一旦被装载了之后

1112
00:33:33,866 --> 00:33:36,500
它的这个 heap 通常比较小

1113
00:33:36,666 --> 00:33:37,066
基本上

1114
00:33:37,066 --> 00:33:40,000
就是把一些 C 库的一些基本的东西

1115
00:33:40,000 --> 00:33:43,100
内存分配的东西给它容纳了就行了

1116
00:33:43,100 --> 00:33:45,033
然后你要分配更多的东西呢

1117
00:33:45,033 --> 00:33:46,600
这个 heap 它就要往上涨

1118
00:33:46,833 --> 00:33:48,366
那涨的时候怎么涨呢

1119
00:33:48,366 --> 00:33:53,400
就是调 brk 或者 sbrk

1120
00:33:53,400 --> 00:33:54,833
这两个系统调用啊

1121
00:33:54,833 --> 00:33:55,633
这两个系统调用

1122
00:33:55,633 --> 00:33:59,366
就是请求内存给我的堆

1123
00:33:59,366 --> 00:34:01,300
给我这当前这个进程的堆

1124
00:34:01,633 --> 00:34:03,533
分配更多的

1125
00:34:03,600 --> 00:34:05,066
更多的虚拟地址空间

1126
00:34:05,533 --> 00:34:06,600
这个虚拟地址空间呢

1127
00:34:06,600 --> 00:34:08,633
就是用来容纳我们的堆的

1128
00:34:08,633 --> 00:34:09,800
通常的堆的

1129
00:34:09,800 --> 00:34:12,966
这就是 brk/sbrk 的作用

1130
00:34:13,200 --> 00:34:15,833
那 brk 就是我指定一个地址

1131
00:34:15,833 --> 00:34:17,066
你给我涨上去

1132
00:34:17,066 --> 00:34:18,933
sbrk 是指定一个 size

1133
00:34:18,933 --> 00:34:19,666
你给我涨上去

1134
00:34:19,666 --> 00:34:21,033
它们俩的区别就在这儿

1135
00:34:21,066 --> 00:34:21,700
那程序呢

1136
00:34:21,700 --> 00:34:25,333
通常我们的应用程序不需要自己亲自去调这个

1137
00:34:25,333 --> 00:34:26,233
那干什么呢

1138
00:34:26,266 --> 00:34:28,466
我们只要做什么工作

1139
00:34:28,466 --> 00:34:30,133
就是调  malloc 就行了

1140
00:34:30,133 --> 00:34:32,266
malloc 会把这些事全给干了

1141
00:34:32,800 --> 00:34:34,066
那再往上

1142
00:34:34,066 --> 00:34:35,066
再往上是什么呢

1143
00:34:35,066 --> 00:34:36,300
就是内核的地址

1144
00:34:36,300 --> 00:34:37,333
内核的

1145
00:34:38,500 --> 00:34:40,533
内核的它的那个代码啊什么

1146
00:34:40,533 --> 00:34:42,133
那些是特权级代码嘛

1147
00:34:42,133 --> 00:34:43,866
我们应用程序是肯定是调不到

1148
00:34:43,866 --> 00:34:44,433
但是呢

1149
00:34:44,433 --> 00:34:46,233
一旦我进入到内核态

1150
00:34:46,233 --> 00:34:48,800
我通过系统调用进入到内核态的时候

1151
00:34:48,933 --> 00:34:50,766
它就会调用内核的这些代码

1152
00:34:51,066 --> 00:34:54,300
这些代码它就会映射到这个进程的

1153
00:34:54,300 --> 00:34:55,866
上面的这个地址空间里边

1154
00:34:55,866 --> 00:34:57,266
就比如说举个例子

1155
00:34:57,333 --> 00:34:58,533
4G 嘛

1156
00:34:59,400 --> 00:35:00,933
这是最高的地址 4GB

1157
00:35:00,966 --> 00:35:01,566
这是 0

1158
00:35:02,866 --> 00:35:04,200
然后大概 Stack 呢

1159
00:35:04,200 --> 00:35:07,100
就是从 3GB 开始的往下走

1160
00:35:07,266 --> 00:35:10,200
然后中间是留给 mmap 用的

1161
00:35:10,300 --> 00:35:12,566
然后这是 heap

1162
00:35:12,633 --> 00:35:15,000
这就是我们叫做这个

1163
00:35:15,200 --> 00:35:19,100
把一个程序装载到这个系统里面之后

1164
00:35:19,100 --> 00:35:24,300
它的这个虚拟地址空间的基本的布局

1165
00:35:24,300 --> 00:35:26,700
这个布局叫 layout

1166
00:35:26,733 --> 00:35:28,466
那这个东西里边的话呢

1167
00:35:28,466 --> 00:35:30,366
实际上我们现在就给大家解释一下

1168
00:35:30,566 --> 00:35:33,833
BSS data text这些东西分别代表什么啊

1169
00:35:34,166 --> 00:35:35,533
实际上很简单啊

1170
00:35:35,800 --> 00:35:38,433
text 就是也叫 code

1171
00:35:38,966 --> 00:35:41,200
不知道为什么它们取名叫 text

1172
00:35:41,200 --> 00:35:43,500
就是代码

1173
00:35:43,500 --> 00:35:44,300
就是代码段

1174
00:35:44,300 --> 00:35:46,566
就是说我程序本身的代码

1175
00:35:46,566 --> 00:35:49,500
以及我用的那些共享库的代码

1176
00:35:49,933 --> 00:35:52,466
它全都会映射到这个区域

1177
00:35:52,466 --> 00:35:53,500
这个区域里边

1178
00:35:53,500 --> 00:35:55,333
这是一个，很容易理解了

1179
00:35:55,333 --> 00:35:58,500
这个代码段的虚拟地址呢

1180
00:35:58,500 --> 00:35:59,400
有一个特点

1181
00:35:59,566 --> 00:36:00,533
它是只读的

1182
00:36:00,533 --> 00:36:01,533
可执行的

1183
00:36:01,666 --> 00:36:03,600
但是呢不能写

1184
00:36:03,600 --> 00:36:05,100
一写就程序夸嚓了

1185
00:36:05,100 --> 00:36:06,066
你就随便你

1186
00:36:06,066 --> 00:36:09,400
比如说这个地址大概是从 4K 开始往上走

1187
00:36:09,466 --> 00:36:12,300
你直接往 4K 上面的东西去弄

1188
00:36:12,366 --> 00:36:15,000
那程序就肯定 segment fault，对吧

1189
00:36:15,300 --> 00:36:16,733
这是只读可执行

1190
00:36:17,066 --> 00:36:17,766
 Data

1191
00:36:17,766 --> 00:36:18,833
Data 指什么呢

1192
00:36:19,133 --> 00:36:21,033
Data 就是我们在程序里边

1193
00:36:21,033 --> 00:36:22,133
比如举个例子

1194
00:36:22,133 --> 00:36:23,100
static

1195
00:36:23,900 --> 00:36:25,233
或者是全局变量

1196
00:36:25,633 --> 00:36:28,900
int a=40

1197
00:36:30,433 --> 00:36:31,733
那还有一个呢

1198
00:36:31,900 --> 00:36:33,200
也是 static

1199
00:36:35,200 --> 00:36:38,300
这个 static 既可以是函数里边的

1200
00:36:38,300 --> 00:36:40,433
也可以是那个函数外的

1201
00:36:40,533 --> 00:36:45,733
比如说是 b=0

1202
00:36:46,700 --> 00:36:47,733
那我们通常知道

1203
00:36:47,733 --> 00:36:49,033
如果是一个全局变量的话

1204
00:36:49,033 --> 00:36:50,400
你如果不初始化的话

1205
00:36:50,400 --> 00:36:51,766
它就是默认是 0 嘛

1206
00:36:51,833 --> 00:36:52,233
对吧

1207
00:36:52,233 --> 00:36:53,033
那有些呢

1208
00:36:53,033 --> 00:36:54,033
我初始化了

1209
00:36:54,133 --> 00:36:55,800
那这些数你得记着呀

1210
00:36:55,966 --> 00:36:57,166
对吧，你得记着呀

1211
00:36:57,400 --> 00:36:59,966
那没有初始化的肯定是 0 嘛

1212
00:36:59,966 --> 00:37:01,766
所以呢我们就可以不用记着

1213
00:37:01,766 --> 00:37:02,500
对不对

1214
00:37:02,500 --> 00:37:05,933
那这个就放在这个 BSS 里边

1215
00:37:05,933 --> 00:37:06,433
这是呢

1216
00:37:06,433 --> 00:37:09,900
就是我们将来要把它初始化成

1217
00:37:09,900 --> 00:37:11,566
就是未初始化的

1218
00:37:13,600 --> 00:37:15,000
这是初始化

1219
00:37:15,966 --> 00:37:17,766
那也就是说 40 这个东西呢

1220
00:37:17,766 --> 00:37:19,133
它会放到这（data）

1221
00:37:19,133 --> 00:37:19,766
这个东西呢（0）

1222
00:37:19,766 --> 00:37:20,933
它会放到这（BSS）

1223
00:37:20,933 --> 00:37:22,133
它的区别就在这样

1224
00:37:22,600 --> 00:37:23,166
那实际上

1225
00:37:23,166 --> 00:37:25,133
我们生成一个可执行文件的时候

1226
00:37:25,900 --> 00:37:28,866
未初始化的这个东西实质上很简单

1227
00:37:29,200 --> 00:37:31,300
因为它不需要保存东西

1228
00:37:31,366 --> 00:37:32,666
它只需要保存什么

1229
00:37:32,666 --> 00:37:36,166
一个符号表对应的那个地址

1230
00:37:36,333 --> 00:37:37,966
就是比如说 b，是吧

1231
00:37:37,966 --> 00:37:39,000
它对应哪个地址

1232
00:37:39,000 --> 00:37:40,933
这是一个符号表里面它要保存的

1233
00:37:41,133 --> 00:37:41,933
另外呢

1234
00:37:42,333 --> 00:37:44,766
只需要保存一个长度就行了

1235
00:37:44,766 --> 00:37:45,500
最长多少

1236
00:37:45,500 --> 00:37:47,266
比如说这是 1K 2K 3K 4K

1237
00:37:47,400 --> 00:37:48,566
然后装载完了之后

1238
00:37:48,566 --> 00:37:49,600
就把这个东西呢

1239
00:37:49,966 --> 00:37:50,933
初始化成 0

1240
00:37:50,966 --> 00:37:51,533
对不对

1241
00:37:51,733 --> 00:37:52,333
但是呢

1242
00:37:52,333 --> 00:37:53,300
data 里边的东西呢

1243
00:37:53,300 --> 00:37:55,666
它是要按照这个内存布局是吧

1244
00:37:55,666 --> 00:37:56,900
内存什么对齐

1245
00:37:56,900 --> 00:37:57,700
这些东西

1246
00:37:57,733 --> 00:37:59,366
要把它记录下来

1247
00:37:59,366 --> 00:38:01,666
记录到这个可执行程序里边

1248
00:38:01,666 --> 00:38:04,266
然后装载的时候要把它原封不动的装载进去

1249
00:38:04,966 --> 00:38:06,366
这些代码呢

1250
00:38:06,466 --> 00:38:08,833
这些虚拟地址 页

1251
00:38:09,533 --> 00:38:10,566
它的特点是什么

1252
00:38:10,800 --> 00:38:11,633
可读可写

1253
00:38:11,833 --> 00:38:13,566
但是不能执行，对吧

1254
00:38:13,566 --> 00:38:16,166
也就是说我们随便找一个 p，是吧

1255
00:38:16,800 --> 00:38:18,066
那么然后这个 p 呢

1256
00:38:18,066 --> 00:38:19,966
它指针 p

1257
00:38:20,266 --> 00:38:20,866
这个 p 呢

1258
00:38:20,866 --> 00:38:24,233
我把它强制转换成一个函数指针

1259
00:38:24,233 --> 00:38:25,600
然后我要去执行它

1260
00:38:26,500 --> 00:38:29,800
程序会干什么 segment fault

1261
00:38:29,800 --> 00:38:30,366
对吧

1262
00:38:30,533 --> 00:38:32,466
这也是不行的，对不对

1263
00:38:32,633 --> 00:38:35,066
然后再往上就是我们讲的这个 heap

1264
00:38:35,066 --> 00:38:38,433
实际上我们讲我们的这个内存堆、栈

1265
00:38:38,433 --> 00:38:39,500
这样的管理的时候

1266
00:38:39,500 --> 00:38:41,100
实际上主要就讲的是 heap

1267
00:38:41,100 --> 00:38:42,100
因为这些东西呢

1268
00:38:42,500 --> 00:38:43,633
程序编译完了之后

1269
00:38:43,633 --> 00:38:44,233
它就定了

1270
00:38:44,233 --> 00:38:46,266
然后就把它装载进来跑就行了

1271
00:38:46,266 --> 00:38:47,833
它基本上是不变的

1272
00:38:47,833 --> 00:38:48,966
除非你程序呢

1273
00:38:48,966 --> 00:38:50,766
改了它的内容，对不对

1274
00:38:50,766 --> 00:38:51,200
所以的话

1275
00:38:51,200 --> 00:38:52,800
那个东西就没什么好讲的

1276
00:38:52,800 --> 00:38:55,033
那我们接下来就给大家讲讲这个 heap

1277
00:38:55,100 --> 00:38:56,866
heap 我们不是说吗

1278
00:38:56,866 --> 00:38:57,900
malloc 是不是

1279
00:38:57,900 --> 00:38:59,666
然后呢不够的时候呢

1280
00:38:59,666 --> 00:39:00,966
再 brk 对吧

1281
00:39:00,966 --> 00:39:03,466
brk 就告诉系统内核

1282
00:39:03,700 --> 00:39:05,666
我这个堆不够大了

1283
00:39:05,666 --> 00:39:07,200
你得给我增长增长

1284
00:39:07,200 --> 00:39:10,033
给我更多的虚拟地址

1285
00:39:10,033 --> 00:39:12,200
然后呢我在那里边再去分配

1286
00:39:12,433 --> 00:39:12,666
好

1287
00:39:12,666 --> 00:39:13,833
我们再回过头来

1288
00:39:13,833 --> 00:39:16,800
刚才所讲的那个就是 BSS

1289
00:39:16,966 --> 00:39:20,933
它就是这个叫 Block Started by Symbol

1290
00:39:20,933 --> 00:39:23,133
就是简称成 BSS

1291
00:39:23,300 --> 00:39:23,933
那后来呢

1292
00:39:23,933 --> 00:39:26,133
一般都不说这个词了

1293
00:39:26,300 --> 00:39:31,533
那一般都叫做 uninitialized data segment

1294
00:39:32,000 --> 00:39:35,533
指的是就是未初始化的数据段

1295
00:39:35,633 --> 00:39:37,100
就是叫 BSS

1296
00:39:37,100 --> 00:39:39,100
但是 BSS 这个英文呢

1297
00:39:39,100 --> 00:39:40,866
叫 Block Started by Symbol

1298
00:39:41,000 --> 00:39:43,566
实际上也就是说我这块的内容呢

1299
00:39:43,566 --> 00:39:46,133
实际上要通过符号表来去索引它

1300
00:39:46,366 --> 00:39:47,700
也可以这么去理解

1301
00:39:47,700 --> 00:39:48,500
但是呢

1302
00:39:49,200 --> 00:39:50,966
一般现在不这么说了

1303
00:39:50,966 --> 00:39:53,700
但是这个简写一直大家就留下来了

1304
00:39:53,966 --> 00:39:56,366
好，我们接下来再讲

1305
00:39:56,366 --> 00:39:58,700
我们的这个堆的分配算法

1306
00:39:58,733 --> 00:40:00,800
或者是堆的这个分配之前

1307
00:40:00,800 --> 00:40:02,366
先给大家说说

1308
00:40:02,366 --> 00:40:03,166
说什么呢

1309
00:40:03,466 --> 00:40:05,466
我们的就是常用的一些工具

1310
00:40:05,466 --> 00:40:07,733
就是我们一个可执行程序编译完了

1311
00:40:07,733 --> 00:40:08,133
对吧

1312
00:40:08,133 --> 00:40:11,733
那有些工具大家要了解

1313
00:40:11,733 --> 00:40:12,833
这里边给了 5 个

1314
00:40:12,833 --> 00:40:14,533
一个叫做 nm

1315
00:40:14,600 --> 00:40:16,366
nm 就是 name list， symbol table

1316
00:40:16,400 --> 00:40:18,400
实际上就是它打印什么呢

1317
00:40:18,500 --> 00:40:21,100
这个程序的这个符号啊

1318
00:40:21,300 --> 00:40:22,133
符号表

1319
00:40:22,133 --> 00:40:23,600
符号指什么

1320
00:40:24,500 --> 00:40:26,533
符号实质上指的是什么呢

1321
00:40:26,566 --> 00:40:28,700
就是我们 C 程序里边

1322
00:40:28,766 --> 00:40:32,800
给这些变量以及函数取得那个名字

1323
00:40:32,800 --> 00:40:33,766
那个名字呢

1324
00:40:34,066 --> 00:40:37,000
在术语里面叫 symbol

1325
00:40:37,233 --> 00:40:39,266
翻译过来叫符号

1326
00:40:39,333 --> 00:40:40,233
有的时候呢

1327
00:40:40,566 --> 00:40:42,100
可能会翻译成别的东西

1328
00:40:42,100 --> 00:40:44,666
但是这个 symbol 在这种常见场景底下

1329
00:40:44,666 --> 00:40:45,700
它指的是什么呢

1330
00:40:45,700 --> 00:40:47,566
就是我取的那些名字

1331
00:40:47,733 --> 00:40:49,800
也就是 name list

1332
00:40:50,133 --> 00:40:53,500
那还有一个叫 strings，后面有个 s

1333
00:40:53,500 --> 00:40:54,333
这是个命令

1334
00:40:54,933 --> 00:40:57,100
也叫做 binary utilities

1335
00:40:57,100 --> 00:40:59,166
就是二进制工具啊

1336
00:40:59,166 --> 00:41:00,733
这些呢是 GCC

1337
00:41:00,800 --> 00:41:01,300
一般啊

1338
00:41:01,300 --> 00:41:02,166
就是编译器

1339
00:41:02,166 --> 00:41:04,000
它都会自带这样的一些工具

1340
00:41:04,133 --> 00:41:04,566
通常呢

1341
00:41:04,566 --> 00:41:05,500
我们装系统的时候

1342
00:41:05,500 --> 00:41:06,666
这些东西都会有

1343
00:41:07,166 --> 00:41:09,333
装个 Linux 里面全都有这些命令

1344
00:41:09,500 --> 00:41:11,066
那我们接下来看一看

1345
00:41:11,066 --> 00:41:13,333
这些命令的这个具体的输出

1346
00:41:13,400 --> 00:41:15,200
大家有感性的认识

1347
00:41:16,966 --> 00:41:17,966
好你看啊

1348
00:41:17,966 --> 00:41:19,500
我刚才说 nm 吧

1349
00:41:20,333 --> 00:41:21,100
我们看一看

1350
00:41:21,100 --> 00:41:23,700
这是我们写的那个 HVML 的解释器

1351
00:41:24,333 --> 00:41:26,366
还有 nm 我们看一下

1352
00:41:26,366 --> 00:41:27,733
一个可执行程序

1353
00:41:27,933 --> 00:41:29,533
它的这个输出

1354
00:41:29,533 --> 00:41:31,100
大概呢就是大家就可以看到

1355
00:41:31,100 --> 00:41:32,466
你看它这里面

1356
00:41:32,466 --> 00:41:35,166
就会把这个符号表整个的打印出来

1357
00:41:35,166 --> 00:41:37,166
这个符号表里面有很多东西

1358
00:41:37,166 --> 00:41:38,900
就比如说大写的 U

1359
00:41:38,900 --> 00:41:41,300
你看大写的 U 指什么呢

1360
00:41:41,500 --> 00:41:42,966
前面没有这个值啊

1361
00:41:43,200 --> 00:41:45,600
就说明这个符号呢

1362
00:41:45,600 --> 00:41:47,000
就是一个 defined

1363
00:41:47,166 --> 00:41:49,300
就是在这个程序本身里面

1364
00:41:49,433 --> 00:41:50,533
它没有被定义

1365
00:41:51,066 --> 00:41:52,666
那实质上它在哪定义呢

1366
00:41:52,666 --> 00:41:55,433
C 库嘛，大家一看就 pthread 打头的

1367
00:41:55,500 --> 00:41:56,833
不就是那个 C 库里面的

1368
00:41:56,833 --> 00:41:57,833
现成的那个线程的接口嘛

1369
00:41:57,900 --> 00:41:58,233
所以呢

1370
00:41:58,233 --> 00:42:01,200
它这里边标记叫做大写的 U

1371
00:42:01,200 --> 00:42:02,933
大写的 U 表示什么呢

1372
00:42:03,066 --> 00:42:04,833
这个是一个函数

1373
00:42:05,100 --> 00:42:06,133
这个函数呢

1374
00:42:06,133 --> 00:42:08,333
在这个可执行程序里面

1375
00:42:08,333 --> 00:42:09,566
本身没有被定义

1376
00:42:10,533 --> 00:42:11,800
然后呢你看这个 t

1377
00:42:13,100 --> 00:42:13,566
t 是什么呢

1378
00:42:13,566 --> 00:42:14,300
小写的 t

1379
00:42:14,300 --> 00:42:15,733
你要前面有值吧

1380
00:42:15,933 --> 00:42:16,900
那就表示什么

1381
00:42:16,900 --> 00:42:18,533
这个是一个 text

1382
00:42:18,533 --> 00:42:20,133
也就是实际上就是个函数

1383
00:42:20,366 --> 00:42:21,033
代码

1384
00:42:21,633 --> 00:42:23,700
这个代码这一看呢

1385
00:42:23,700 --> 00:42:24,200
这个东西呢

1386
00:42:24,200 --> 00:42:27,166
就是在这个程序里面自己就定义

1387
00:42:27,366 --> 00:42:29,033
然后呢这个 D 的是什么呢

1388
00:42:29,033 --> 00:42:30,600
那显然就是数据

1389
00:42:30,600 --> 00:42:31,200
数据

1390
00:42:31,266 --> 00:42:33,500
也是在这个程序里面本身有定义

1391
00:42:33,500 --> 00:42:34,566
就是这个东西

1392
00:42:34,566 --> 00:42:36,200
就是它的地址在这

1393
00:42:36,200 --> 00:42:37,000
地址在这

1394
00:42:37,233 --> 00:42:38,733
你看这个很好理解了吧

1395
00:42:39,333 --> 00:42:40,666
我们再来看 size

1396
00:42:43,800 --> 00:42:45,666
size 你看

1397
00:42:45,666 --> 00:42:46,400
大家看到

1398
00:42:46,400 --> 00:42:48,666
就是它实际上就打印了一个统计信息

1399
00:42:48,800 --> 00:42:49,933
这个统计信息是什么呢

1400
00:42:49,933 --> 00:42:51,266
就是一个可执行程序

1401
00:42:51,266 --> 00:42:52,866
它的 text 段多大

1402
00:42:52,866 --> 00:42:55,533
你看这个一共有 403

1403
00:42:55,533 --> 00:42:56,666
403K

1404
00:42:56,966 --> 00:42:58,400
那 Data 段有多少

1405
00:42:58,400 --> 00:43:00,000
然后 BSS 段有多少

1406
00:43:00,000 --> 00:43:01,500
也就是说你这里边呢

1407
00:43:01,700 --> 00:43:03,100
未初始化的数据

1408
00:43:03,100 --> 00:43:05,566
也就是 79K

1409
00:43:05,700 --> 00:43:06,600
初始化的数据呢

1410
00:43:06,600 --> 00:43:07,666
有 17K

1411
00:43:07,666 --> 00:43:10,166
这里面有可能是字符串常量，对吧

1412
00:43:10,300 --> 00:43:11,100
然后呢

1413
00:43:11,100 --> 00:43:11,933
还有什么呢

1414
00:43:11,933 --> 00:43:14,466
还有就是比如说是那个立即数

1415
00:43:14,466 --> 00:43:16,500
40 50 这样的一些东西

1416
00:43:16,833 --> 00:43:19,800
然后这里边后面还有两个值

1417
00:43:19,800 --> 00:43:21,433
我在这里面考考大家

1418
00:43:21,766 --> 00:43:24,233
这个 dec 和 hex 分别表示啥

1419
00:43:24,966 --> 00:43:25,800
考考大家

1420
00:43:26,166 --> 00:43:27,600
大家在思考的时候呢

1421
00:43:27,600 --> 00:43:30,200
我顺便把剩下的那个也说了啊

1422
00:43:31,766 --> 00:43:33,766
哎比如说strings这个命令

1423
00:43:34,300 --> 00:43:35,500
就是打印出什么呢

1424
00:43:35,500 --> 00:43:36,666
打印出这个

1425
00:43:36,933 --> 00:43:39,366
这个一个可执行程序里边的

1426
00:43:39,366 --> 00:43:41,000
所有的什么呢

1427
00:43:41,333 --> 00:43:42,700
所有的就是字符串

1428
00:43:42,700 --> 00:43:44,133
实际上也就是字符串常量

1429
00:43:44,166 --> 00:43:46,000
那你看我们这里面为什么这么多

1430
00:43:46,000 --> 00:43:48,100
把一些函数全都打印出来了

1431
00:43:48,100 --> 00:43:50,166
这个就是明显是因为什么呢

1432
00:43:50,166 --> 00:43:51,966
因为这个可执行程序里面

1433
00:43:51,966 --> 00:43:54,300
包括了调试符号

1434
00:43:55,300 --> 00:43:56,466
就比如举个例子

1435
00:43:56,466 --> 00:43:59,500
gdb 怎么知道这个程序跑到了哪个地方

1436
00:43:59,500 --> 00:43:59,900
然后呢

1437
00:43:59,900 --> 00:44:03,066
哪个地方的这个在哪个函数里边呢

1438
00:44:03,066 --> 00:44:05,033
就是因为有这个函数

1439
00:44:05,033 --> 00:44:06,733
以及它对应的那个函数名

1440
00:44:06,733 --> 00:44:09,166
它已经包含在那个可执行程序里面了

1441
00:44:09,333 --> 00:44:11,900
所以它就能够找到这些东西，对吧

1442
00:44:11,900 --> 00:44:14,100
如果我我们 strip 一下

1443
00:44:14,100 --> 00:44:16,300
就比如说我们 strip 一下这个程序

1444
00:44:16,500 --> 00:44:17,700
我们会看到这个

1445
00:44:17,700 --> 00:44:18,533
它的这个

1446
00:44:19,666 --> 00:44:23,133
它的这个字符串就会变少很多

1447
00:44:23,133 --> 00:44:24,466
你看很多东西就没了

1448
00:44:24,466 --> 00:44:25,700
就变少很多

1449
00:44:25,700 --> 00:44:26,166
变少很多

1450
00:44:26,166 --> 00:44:26,733
这是为什么

1451
00:44:26,733 --> 00:44:28,000
就是我把那些那个

1452
00:44:28,000 --> 00:44:30,966
strip 就剥离的意思，对吧

1453
00:44:30,966 --> 00:44:33,333
它就会把那些符号表里面

1454
00:44:33,900 --> 00:44:35,700
仅仅用于调试的那些东西

1455
00:44:35,700 --> 00:44:36,966
全都给扔掉

1456
00:44:36,966 --> 00:44:39,733
它的这个可执行程序也会变小

1457
00:44:39,733 --> 00:44:41,166
可执行程序也会变小

1458
00:44:41,166 --> 00:44:42,366
那这个东西有什么用啊

1459
00:44:42,700 --> 00:44:43,266
有什么用啊

1460
00:44:43,266 --> 00:44:45,100
就比如说我们搞嵌入式系统吧

1461
00:44:45,166 --> 00:44:45,533
对吧

1462
00:44:45,533 --> 00:44:48,766
经常想要把这个有限的存储空间里面塞

1463
00:44:48,766 --> 00:44:51,166
塞进去更多的这个内容

1464
00:44:51,166 --> 00:44:51,766
是不是

1465
00:44:51,766 --> 00:44:54,366
那 Strip 命令通常非常有用

1466
00:44:54,366 --> 00:44:54,766
非常有用

1467
00:44:54,766 --> 00:44:57,633
就是把那些不要的符号表

1468
00:44:57,633 --> 00:44:59,700
比如说一个 C++ 的程序

1469
00:45:00,033 --> 00:45:01,100
一个符号表

1470
00:45:01,133 --> 00:45:03,066
如果你有调试信息的时候

1471
00:45:03,066 --> 00:45:04,700
它可能有 100M

1472
00:45:05,433 --> 00:45:07,266
如果你 strip 一下

1473
00:45:07,266 --> 00:45:08,533
只有 10 兆

1474
00:45:08,533 --> 00:45:11,700
它通常就有可能会是这样子的一个变化

1475
00:45:11,733 --> 00:45:14,233
这个是非常非常好的一个工具

1476
00:45:14,933 --> 00:45:16,233
好

1477
00:45:16,233 --> 00:45:19,166
我们再回过头来看这个 PPT 的内容

1478
00:45:20,700 --> 00:45:22,066
那还有两个

1479
00:45:22,066 --> 00:45:25,033
就是 readelf 和 objdump

1480
00:45:25,033 --> 00:45:25,566
这些东西呢

1481
00:45:25,566 --> 00:45:27,600
可以更详细的去了解什么呢

1482
00:45:27,600 --> 00:45:30,500
了解一个可执行程序的一些内部的一些信息

1483
00:45:30,900 --> 00:45:32,366
比如说 elf 大家都知道

1484
00:45:32,366 --> 00:45:33,233
就是一个

1485
00:45:33,233 --> 00:45:34,866
除了 a.out 之外呢

1486
00:45:34,866 --> 00:45:36,033
elf 是另外一个

1487
00:45:36,033 --> 00:45:38,966
就现在流行的一个可执行程序的什么呢

1488
00:45:38,966 --> 00:45:40,333
一个格式

1489
00:45:40,333 --> 00:45:42,633
可执行程序本身也是一个文件嘛

1490
00:45:42,633 --> 00:45:45,900
所以呢它跟 png jpeg 什么之类的

1491
00:45:45,900 --> 00:45:47,633
它都有一个固定的格式

1492
00:45:47,700 --> 00:45:49,133
里面先保存什么

1493
00:45:49,133 --> 00:45:50,433
后保存什么

1494
00:45:50,433 --> 00:45:51,733
之类的这样一些信息

1495
00:45:51,833 --> 00:45:53,066
那 readelf 呢

1496
00:45:53,066 --> 00:45:53,966
就是不执行它

1497
00:45:53,966 --> 00:45:57,833
但是我把这些信息给你展示出来的

1498
00:45:57,833 --> 00:45:58,766
这就是这个

1499
00:45:58,966 --> 00:45:59,166
好

1500
00:45:59,166 --> 00:46:03,133
我们除了就是说我们常用的这个 malloc calloc

1501
00:46:03,133 --> 00:46:04,566
还有这个 brk

1502
00:46:04,566 --> 00:46:06,066
这些系统调用之外

1503
00:46:06,466 --> 00:46:09,433
还有一些其它的内存的分配方法

1504
00:46:09,433 --> 00:46:11,966
当然我们这里面主要讲 Linux

1505
00:46:11,966 --> 00:46:14,400
你在嵌入系统上恐怕是没有这种

1506
00:46:14,400 --> 00:46:17,133
就尤其是 RTOS 上恐怕是没有这种东西的

1507
00:46:17,233 --> 00:46:18,633
那这些东西的实现呢

1508
00:46:18,633 --> 00:46:20,366
实质上它也是依赖于什么

1509
00:46:20,366 --> 00:46:21,833
依赖于虚拟内存嘛

1510
00:46:21,933 --> 00:46:23,166
因为有虚拟内存

1511
00:46:23,166 --> 00:46:24,366
所以才能干这个事

1512
00:46:24,666 --> 00:46:25,633
首先是 mmap

1513
00:46:25,633 --> 00:46:27,333
大家都知道吗

1514
00:46:27,333 --> 00:46:31,933
mmap 本身是把文件的内容映射到内存里边

1515
00:46:32,800 --> 00:46:35,066
然后呢我去操作这个内存

1516
00:46:35,066 --> 00:46:37,433
就相当于是操作这个文件

1517
00:46:37,800 --> 00:46:38,600
对吧

1518
00:46:38,733 --> 00:46:42,333
这就是 mmap 的作用

1519
00:46:42,600 --> 00:46:43,133
但是呢

1520
00:46:43,133 --> 00:46:45,533
mmap 后来发展到一定程度的时候呢

1521
00:46:45,533 --> 00:46:47,466
就增加了一个什么东西呢

1522
00:46:47,466 --> 00:46:50,366
增加了一个匿名映射的这么一个标志

1523
00:46:51,266 --> 00:46:52,366
匿名映射指什么呢

1524
00:46:52,366 --> 00:46:54,933
就是说你别

1525
00:46:54,933 --> 00:46:57,533
后面不要有什么文件

1526
00:46:57,533 --> 00:46:58,433
匿名的

1527
00:46:58,600 --> 00:47:01,466
也就是说我实际上 mmap 出来的什么呢

1528
00:47:01,533 --> 00:47:04,566
是一个没跟具体的文件相关联的

1529
00:47:04,566 --> 00:47:07,066
这么一块虚拟地址空间

1530
00:47:07,466 --> 00:47:09,400
那这块虚拟地址空间如果呢

1531
00:47:09,400 --> 00:47:10,833
你往这里边写的时候

1532
00:47:11,233 --> 00:47:14,000
它就会给你分配一个物理内存

1533
00:47:14,000 --> 00:47:14,866
让它去写

1534
00:47:15,166 --> 00:47:15,466
对吧

1535
00:47:15,466 --> 00:47:16,366
那这样的话呢

1536
00:47:16,366 --> 00:47:18,266
实际上它本质上就变成了什么

1537
00:47:18,433 --> 00:47:20,600
变成了分配一块物理内存

1538
00:47:21,033 --> 00:47:21,800
那我们在

1539
00:47:21,800 --> 00:47:23,766
比如说我们做图形的

1540
00:47:23,766 --> 00:47:26,133
经常不是要分配那个帧缓冲区吗

1541
00:47:26,133 --> 00:47:27,733
那帧缓冲区很大呀

1542
00:47:27,733 --> 00:47:28,533
就通常

1543
00:47:28,966 --> 00:47:29,200
一般

1544
00:47:29,200 --> 00:47:31,600
比如说，大家可以很快的算一下

1545
00:47:31,600 --> 00:47:34,366
640*480 的一个分辨率

1546
00:47:34,733 --> 00:47:38,433
32 位色那需要多大的这个空间

1547
00:47:39,833 --> 00:47:40,833
这个一般来讲的话

1548
00:47:40,833 --> 00:47:41,633
通常呢

1549
00:47:41,966 --> 00:47:43,866
有的时候在上兆，对吧

1550
00:47:43,866 --> 00:47:46,766
如果是 1080P 的那个分别率那就更大了

1551
00:47:47,033 --> 00:47:47,600
那这个时候呢

1552
00:47:47,600 --> 00:47:49,600
这种大内存的这个分配

1553
00:47:49,633 --> 00:47:52,133
我们通常都会通过什么呢

1554
00:47:52,133 --> 00:47:56,000
通过像 mmap 这种函数来分配

1555
00:47:56,200 --> 00:47:57,400
那就非常好使

1556
00:47:57,400 --> 00:47:58,200
非常好使

1557
00:47:58,400 --> 00:47:59,033
还有一个

1558
00:47:59,033 --> 00:48:01,233
还有一个叫做 memfd

1559
00:48:01,233 --> 00:48:01,800
这个东西呢

1560
00:48:01,800 --> 00:48:03,833
我在下一讲也会给大家讲

1561
00:48:03,833 --> 00:48:04,833
也会给大家讲

1562
00:48:04,933 --> 00:48:07,566
memfd 就是内存文件描述服务

1563
00:48:07,566 --> 00:48:08,566
什么意思呢

1564
00:48:09,033 --> 00:48:10,833
就是我不是刚才 mmap

1565
00:48:10,833 --> 00:48:13,466
可以匿名创建一个虚拟地址空间吗

1566
00:48:13,466 --> 00:48:13,900
然后呢

1567
00:48:13,900 --> 00:48:16,233
并不映射到具体的一个文件上

1568
00:48:16,300 --> 00:48:17,833
我需要使用它的时候

1569
00:48:17,833 --> 00:48:20,666
它会系统会给它分配什么物理地址

1570
00:48:20,666 --> 00:48:22,800
这就相当于分配一个大块的内存

1571
00:48:23,266 --> 00:48:24,266
memfd 呢

1572
00:48:24,266 --> 00:48:27,233
是顺便给你一个文件描述符

1573
00:48:27,233 --> 00:48:29,066
这个文件描述符有啥好处呢

1574
00:48:29,533 --> 00:48:32,033
文件描述符可以在进程之间传递

1575
00:48:32,766 --> 00:48:34,533
这个我下一节会讲

1576
00:48:34,533 --> 00:48:35,466
下一讲会讲

1577
00:48:35,866 --> 00:48:36,533
这个东西呢

1578
00:48:36,533 --> 00:48:37,733
就非常好使

1579
00:48:37,733 --> 00:48:38,333
为什么？

1580
00:48:38,333 --> 00:48:40,333
它就可以用来共享内存

1581
00:48:41,433 --> 00:48:42,233
什么意思

1582
00:48:42,333 --> 00:48:44,466
我 mmap 不是分配一块内存吗

1583
00:48:44,466 --> 00:48:45,033
如果呢

1584
00:48:45,033 --> 00:48:48,933
我通过 memfd_create() 这个系统调用

1585
00:48:49,733 --> 00:48:51,966
我就同时可以获得一个

1586
00:48:51,966 --> 00:48:54,333
代表这块内存的一个什么呢

1587
00:48:54,333 --> 00:48:55,866
文件描述符

1588
00:48:56,200 --> 00:48:57,133
这个文件描述符

1589
00:48:57,133 --> 00:48:59,866
我可以通过进程 a 传递到进程 b

1590
00:49:00,200 --> 00:49:01,200
那进程 b 呢

1591
00:49:01,200 --> 00:49:03,233
拿到这个文件描述符之后

1592
00:49:03,666 --> 00:49:05,600
我就可以用 mmap

1593
00:49:05,600 --> 00:49:08,633
再把它映射到我的地址空间里边

1594
00:49:08,733 --> 00:49:10,466
那这样子的话呢这两个

1595
00:49:10,633 --> 00:49:12,733
逻辑地址或者虚拟地址块

1596
00:49:13,066 --> 00:49:15,266
是不是就指向了同一个物理地址

1597
00:49:15,666 --> 00:49:17,133
那指向了同一个物理地址

1598
00:49:17,133 --> 00:49:20,766
实际上相当于我就创建了一个共享的内存

1599
00:49:21,266 --> 00:49:22,066
是吧

1600
00:49:22,433 --> 00:49:23,800
这个东西是不是很好玩

1601
00:49:23,800 --> 00:49:24,233
这个东西是不是很好玩

1602
00:49:24,233 --> 00:49:25,066
大家听懂了没有

1603
00:49:25,066 --> 00:49:26,666
听懂了的话就打个 6

1604
00:49:26,666 --> 00:49:28,733
没听懂我在图上也给大家讲讲

1605
00:49:28,733 --> 00:49:31,066
画个图给大家讲讲

1606
00:49:31,266 --> 00:49:33,166
对那个刚才我回过头来说

1607
00:49:33,166 --> 00:49:34,366
刘博说的对

1608
00:49:34,366 --> 00:49:38,666
dec 和 hex 是十进制和十六进制的意思

1609
00:49:38,833 --> 00:49:39,366
就是说

1610
00:49:39,366 --> 00:49:41,366
我也不知道它那个程序

1611
00:49:41,366 --> 00:49:42,200
它设计为什么非得非得那个什么啊

1612
00:49:42,266 --> 00:49:45,233
非得加一个那个 dec hex

1613
00:49:45,233 --> 00:49:46,900
前面是 BSS

1614
00:49:46,900 --> 00:49:49,500
然后是 data 什么这个大小是吧

1615
00:49:49,600 --> 00:49:52,066
然后呢在这它就不好使了

1616
00:49:52,066 --> 00:49:54,033
还是有同学没听明白

1617
00:49:54,033 --> 00:49:56,000
那我就给大家讲一讲啊

1618
00:49:57,100 --> 00:50:01,033
这个 fd 它可不是虚拟地址

1619
00:50:01,033 --> 00:50:02,566
fd 是文件描述符

1620
00:50:02,633 --> 00:50:04,833
在 Linux 底下，Unix 系统里面

1621
00:50:04,833 --> 00:50:09,033
fd 它是一个 123456789 这样的整数

1622
00:50:09,033 --> 00:50:11,900
整数值，0123456789 的整数值

1623
00:50:12,366 --> 00:50:14,233
fd 不是虚拟地址啊

1624
00:50:14,633 --> 00:50:16,366
那么实际上是这样子的啊

1625
00:50:16,600 --> 00:50:18,633
我们这里边的关键呢

1626
00:50:18,633 --> 00:50:21,133
是叫 fd 的一个传输

1627
00:50:25,400 --> 00:50:26,433
传输

1628
00:50:26,533 --> 00:50:31,400
实际上这个也是一个很重要的一个设计哲学

1629
00:50:31,400 --> 00:50:34,933
就 Unix 系统里面一切皆文件

1630
00:50:35,100 --> 00:50:35,600
这个东西

1631
00:50:35,600 --> 00:50:36,466
就是说所有的东西

1632
00:50:36,466 --> 00:50:38,666
我都可以把它抽象成一个文件

1633
00:50:39,200 --> 00:50:41,000
所以呢既然是个文件呢

1634
00:50:41,000 --> 00:50:43,100
那它就可以有文件描述符

1635
00:50:43,100 --> 00:50:43,566
对吧

1636
00:50:43,566 --> 00:50:44,300
所以呢

1637
00:50:44,300 --> 00:50:52,333
在这里边它的这个 memfd_create 这个函数

1638
00:50:57,100 --> 00:50:58,100
这个函数

1639
00:50:58,100 --> 00:50:58,400
实际上

1640
00:50:58,400 --> 00:50:59,500
它会返回一个什么?

1641
00:50:59,500 --> 00:51:01,066
int 型的东西

1642
00:51:01,133 --> 00:51:03,033
它就是一个文件描述符

1643
00:51:03,433 --> 00:51:05,466
fd 在 Linux 系统里边

1644
00:51:06,100 --> 00:51:06,733
一看 fd 啊

1645
00:51:06,733 --> 00:51:09,100
你们取名字的时候千万也不要乱取

1646
00:51:09,333 --> 00:51:13,333
fd 它就是 File descriptor 的简写

1647
00:51:13,500 --> 00:51:15,733
就是永远是这个固定的

1648
00:51:15,800 --> 00:51:18,833
不要给别的东西取名叫 fd

1649
00:51:18,833 --> 00:51:21,933
也不要取 f 啊 d 啊这样的一些简单的名字

1650
00:51:22,066 --> 00:51:24,833
那 fd，它创建的时候

1651
00:51:24,833 --> 00:51:25,966
实际上在内核里面

1652
00:51:25,966 --> 00:51:27,533
它首先创建一块内存

1653
00:51:28,466 --> 00:51:29,066
然后呢

1654
00:51:29,066 --> 00:51:32,133
把它抽象成一个文件描述符来代表它

1655
00:51:33,966 --> 00:51:34,533
代表它

1656
00:51:34,933 --> 00:51:36,333
这个实际上很好理解

1657
00:51:36,333 --> 00:51:37,066
为什么呢

1658
00:51:37,066 --> 00:51:41,333
mmap 本身就可以把一个文件映射成

1659
00:51:41,366 --> 00:51:42,633
映射到内存里边

1660
00:51:42,633 --> 00:51:43,433
对吧

1661
00:51:43,866 --> 00:51:45,233
mmap 是不是

1662
00:51:45,366 --> 00:51:46,600
那既然这样的话呢

1663
00:51:46,600 --> 00:51:48,533
匿名 mmap 是干什么的

1664
00:51:48,533 --> 00:51:50,066
实际上这块内存

1665
00:51:50,066 --> 00:51:53,066
根本就没有对应一个文件描述符

1666
00:51:53,400 --> 00:51:55,266
根本没有对应一个实际的文件

1667
00:51:55,433 --> 00:51:55,633
那

1668
00:51:55,633 --> 00:51:58,833
我也可以让它对应一个虚拟的文件呢

1669
00:51:59,800 --> 00:52:01,233
虚拟的文件描述符

1670
00:52:01,500 --> 00:52:03,500
我给你分配一个文件描述符就行

1671
00:52:03,600 --> 00:52:03,800
对吧

1672
00:52:03,800 --> 00:52:06,700
但这个文件描述符不跟具体的文件挂钩

1673
00:52:07,000 --> 00:52:09,333
我只是让它来代表什么

1674
00:52:10,066 --> 00:52:12,000
代表一个内存

1675
00:52:12,433 --> 00:52:13,766
那就是虚拟的内存块

1676
00:52:13,966 --> 00:52:16,133
就是一个 VM Block

1677
00:52:16,133 --> 00:52:18,466
我们就是 VMB

1678
00:52:18,466 --> 00:52:21,200
我就用 fd 来代表它

1679
00:52:21,700 --> 00:52:22,666
然后呢

1680
00:52:23,500 --> 00:52:24,833
你既然是个 fd

1681
00:52:24,833 --> 00:52:25,833
是不是

1682
00:52:25,833 --> 00:52:28,533
进程 a 里边的 Pa

1683
00:52:29,666 --> 00:52:31,100
然后这个 fd 呢

1684
00:52:31,100 --> 00:52:32,900
它可以通过什么呀

1685
00:52:33,700 --> 00:52:37,266
通过 UNIX Domain Socket

1686
00:52:40,466 --> 00:52:44,433
传递到进程 b 里边去

1687
00:52:45,833 --> 00:52:48,566
这是 Unix 系统的一个特别的地方

1688
00:52:49,000 --> 00:52:52,033
这个 fd 传递到这个进程里边

1689
00:52:52,300 --> 00:52:54,633
只能通过 UNIX Domain Socket 来传递

1690
00:52:54,633 --> 00:52:56,300
这个我会下一节会讲

1691
00:52:56,566 --> 00:52:58,700
但是传递完了这个 fd

1692
00:53:00,000 --> 00:53:01,200
这也是 fd 吧

1693
00:53:01,300 --> 00:53:02,800
但是大家一定要注意啊

1694
00:53:03,033 --> 00:53:04,033
这俩 fd

1695
00:53:04,333 --> 00:53:08,000
它在内核里边指向同一个文件对象

1696
00:53:08,000 --> 00:53:09,933
但是这个 fd 有可能是 5

1697
00:53:09,933 --> 00:53:10,800
比如这个 5

1698
00:53:10,800 --> 00:53:12,533
这个 fd 有可能是 12

1699
00:53:12,533 --> 00:53:13,633
这俩值是不一样的

1700
00:53:13,633 --> 00:53:15,900
不是说传递 fd 是传递那个值

1701
00:53:15,900 --> 00:53:16,366
不是

1702
00:53:16,566 --> 00:53:18,100
它做了一个操作

1703
00:53:18,833 --> 00:53:20,166
就是把这个文件

1704
00:53:20,166 --> 00:53:23,533
它们都指向一个什么？文件对象

1705
00:53:23,533 --> 00:53:24,933
真正的一个文件对象

1706
00:53:25,033 --> 00:53:27,033
我们把它叫做 Fo 吧

1707
00:53:27,566 --> 00:53:28,833
那这个 fd 也指向它

1708
00:53:28,833 --> 00:53:29,833
实际上也就是说

1709
00:53:29,833 --> 00:53:32,366
它复制了一个文件描述符

1710
00:53:32,366 --> 00:53:33,800
然后指向同一个对象

1711
00:53:33,833 --> 00:53:36,333
而这个同一个对象代表的是这个内存块

1712
00:53:36,700 --> 00:53:37,333
然后呢

1713
00:53:37,333 --> 00:53:38,300
有了这个东西之后

1714
00:53:38,300 --> 00:53:39,700
我在 mmap

1715
00:53:41,133 --> 00:53:41,833
这个东西呢

1716
00:53:41,833 --> 00:53:43,933
它就进入到这个 PB 的

1717
00:53:43,933 --> 00:53:47,133
进程的地址空间里面去了

1718
00:53:47,133 --> 00:53:47,666
就比如说

1719
00:53:49,800 --> 00:53:51,933
就是这个VMB啊

1720
00:53:52,233 --> 00:53:53,400
创建完了这个东西

1721
00:53:53,400 --> 00:53:54,700
它就跑到这来了

1722
00:53:55,233 --> 00:53:56,100
那这个时候呢

1723
00:53:56,100 --> 00:53:57,366
我有了这个 fd

1724
00:53:57,400 --> 00:53:59,033
我再调 mmap

1725
00:53:59,300 --> 00:54:01,600
在这个 fd 上做这个 mmap

1726
00:54:03,733 --> 00:54:07,233
它就会进入到这个进程 b 的

1727
00:54:07,233 --> 00:54:08,966
虚拟地址空间里面

1728
00:54:09,166 --> 00:54:11,300
它是这样一个意思

1729
00:54:11,400 --> 00:54:13,500
行我们把这个

1730
00:54:13,500 --> 00:54:15,566
至于这个东西是怎么传递的

1731
00:54:15,566 --> 00:54:16,566
我们把这些细节

1732
00:54:16,566 --> 00:54:17,966
我在下一讲会讲

1733
00:54:17,966 --> 00:54:20,866
这个是一个特别特别重要的一个东西

1734
00:54:20,866 --> 00:54:23,066
就是说  memfd_create

1735
00:54:23,266 --> 00:54:24,966
包括啊，包括什么

1736
00:54:25,033 --> 00:54:27,000
包括我们共享

1737
00:54:27,700 --> 00:54:31,266
共享 GPU 里边的缓冲区

1738
00:54:31,966 --> 00:54:33,300
都是通过 fd

1739
00:54:34,233 --> 00:54:37,033
然后在进程之间传来传去

1740
00:54:37,033 --> 00:54:38,166
传来传去

1741
00:54:38,266 --> 00:54:39,766
我给大家举个例子啊

1742
00:54:40,600 --> 00:54:43,000
就是现在的这个操作系统

1743
00:54:44,433 --> 00:54:45,566
窗口系统啊

1744
00:54:45,566 --> 00:54:46,966
都提供一个什么呢

1745
00:54:46,966 --> 00:54:48,666
就是合成器的模式嘛

1746
00:54:49,500 --> 00:54:51,866
比如说我们都知道那个 Linux 底下

1747
00:54:51,866 --> 00:54:52,833
原来叫 X11

1748
00:54:52,833 --> 00:54:54,233
或者后来叫 Xorg

1749
00:54:54,233 --> 00:54:54,566
对吧

1750
00:54:54,566 --> 00:54:55,100
然后呢

1751
00:54:55,100 --> 00:54:57,433
现在有个叫做 Wayland 的一个东西嘛

1752
00:54:57,633 --> 00:54:59,233
这个 Wayland 它是什么呢

1753
00:54:59,566 --> 00:55:01,900
可以自定义它的合成器

1754
00:55:01,900 --> 00:55:04,566
其中有一个合成器叫 west 什么

1755
00:55:04,566 --> 00:55:06,066
西部世界吧好像叫

1756
00:55:06,066 --> 00:55:07,866
那样的一个合成器

1757
00:55:08,000 --> 00:55:09,633
那这个合成器是干什么的呢

1758
00:55:09,633 --> 00:55:12,433
合成器就是把这些窗口

1759
00:55:13,066 --> 00:55:14,066
把这些窗口

1760
00:55:14,066 --> 00:55:15,433
用合成模式的时候呢

1761
00:55:15,433 --> 00:55:17,800
每一个窗口都有一个自己的 buffer

1762
00:55:18,000 --> 00:55:18,500
缓冲区

1763
00:55:18,500 --> 00:55:20,100
你往这个 里面画

1764
00:55:20,200 --> 00:55:21,166
画完了之后呢

1765
00:55:21,166 --> 00:55:22,166
我再用

1766
00:55:22,166 --> 00:55:25,466
让合成器把这些八法给它合成到一起

1767
00:55:25,466 --> 00:55:27,700
然后再把它放到屏幕上

1768
00:55:27,766 --> 00:55:28,433
这个时候呢

1769
00:55:28,433 --> 00:55:30,766
你就会看到这些窗口之间呢

1770
00:55:30,766 --> 00:55:33,200
就会有层叠的阴影

1771
00:55:34,200 --> 00:55:35,500
那就比如说举个例子

1772
00:55:35,833 --> 00:55:37,266
你看这个窗口是吧

1773
00:55:37,266 --> 00:55:38,133
有个阴影

1774
00:55:38,133 --> 00:55:38,566
然后

1775
00:55:38,766 --> 00:55:40,900
显示在另外一个窗口的上面

1776
00:55:41,133 --> 00:55:43,166
那在传统的以前

1777
00:55:43,166 --> 00:55:44,766
这个点是做不到的

1778
00:55:44,766 --> 00:55:47,866
以前就比如说是在 Windows 95 那个年代的时候

1779
00:55:48,033 --> 00:55:49,900
基本上没有这个技术

1780
00:55:50,233 --> 00:55:51,633
是后来才有的

1781
00:55:51,633 --> 00:55:53,733
比如 Windows 再往前倒 3.1 什么的

1782
00:55:53,733 --> 00:55:55,566
包括 X11 也没有这个能力

1783
00:55:55,566 --> 00:55:57,866
它要实现这个东西很麻烦很麻烦

1784
00:55:58,900 --> 00:55:59,866
那后来呢

1785
00:55:59,866 --> 00:56:02,733
我们有了这个就是 GPU 之后

1786
00:56:02,933 --> 00:56:05,500
那我们这些合成器就专门做这个事

1787
00:56:05,500 --> 00:56:06,833
比如说把这些窗口

1788
00:56:06,833 --> 00:56:08,633
把它们半透明叠加上去

1789
00:56:08,866 --> 00:56:11,133
一个窗口半透明叠加上去

1790
00:56:11,166 --> 00:56:12,333
或者是我在

1791
00:56:12,466 --> 00:56:14,433
甚至在做一个什么模糊效果

1792
00:56:14,433 --> 00:56:14,633
对吧

1793
00:56:14,633 --> 00:56:15,566
大家都知道在那个

1794
00:56:15,566 --> 00:56:16,966
你看在智能手机里面

1795
00:56:16,966 --> 00:56:18,633
经常不就有模糊效果吗

1796
00:56:18,666 --> 00:56:20,266
一个东西盖在一个上面的时候

1797
00:56:20,266 --> 00:56:21,666
你还可以看见底下的东西

1798
00:56:21,666 --> 00:56:23,033
而且底下东西也在动

1799
00:56:23,033 --> 00:56:24,166
你还看见它在动

1800
00:56:24,166 --> 00:56:26,033
只不过模糊了你看不清楚而已

1801
00:56:26,666 --> 00:56:26,966
对吧

1802
00:56:26,966 --> 00:56:28,166
半透明是那种效果

1803
00:56:28,166 --> 00:56:29,233
然后模糊也是

1804
00:56:29,333 --> 00:56:30,633
那所有的这些东西呢

1805
00:56:30,733 --> 00:56:33,566
里边都有一个叫合成器的这样一个

1806
00:56:33,566 --> 00:56:35,766
一个进程在专门干这件事情

1807
00:56:35,766 --> 00:56:36,833
在安卓上叫什么

1808
00:56:36,833 --> 00:56:38,566
SurfaceFlinger 对吧

1809
00:56:38,800 --> 00:56:41,800
那在这个 Linux 底下叫什么呢

1810
00:56:41,833 --> 00:56:43,533
就就是那个 Wayland 底下的

1811
00:56:43,533 --> 00:56:46,066
一个专门的一个合成器进程在干这个事

1812
00:56:46,400 --> 00:56:47,833
然后 Windows 上实际上也一样

1813
00:56:47,833 --> 00:56:49,366
Mac 上实际上也一样

1814
00:56:49,366 --> 00:56:51,433
基本上现在是这个窗口系统是这么设计的

1815
00:56:51,433 --> 00:56:53,433
包括我们 MiniGUI 5.0 也支持这个

1816
00:56:53,600 --> 00:56:55,533
那这样的一个东西的话呢

1817
00:56:55,533 --> 00:56:57,466
我们要去做这件事情的时候呢

1818
00:56:57,733 --> 00:56:59,433
所有的这种缓冲区

1819
00:56:59,666 --> 00:57:03,066
包括我在 GPU 里面分配的那些内存块

1820
00:57:03,833 --> 00:57:05,366
那个叫 buffer

1821
00:57:05,466 --> 00:57:08,266
那些 buffer 全都有对应的一个 fd

1822
00:57:08,633 --> 00:57:12,066
然后通过 UNIX Domain Socket 的这种机制

1823
00:57:12,100 --> 00:57:13,900
把这些 fd 从一个进程

1824
00:57:13,900 --> 00:57:16,133
传到合成器那个进程里面

1825
00:57:16,166 --> 00:57:19,333
那合成器那个进程就可以通过 mmap

1826
00:57:19,333 --> 00:57:22,166
把这个内存再映射到自己的进程地址空间里

1827
00:57:22,166 --> 00:57:24,300
然后我就可以访问那些内容了

1828
00:57:24,366 --> 00:57:24,733
对吧

1829
00:57:24,733 --> 00:57:26,700
那访问这个内容的时候

1830
00:57:26,866 --> 00:57:27,900
我既然可以访问

1831
00:57:27,900 --> 00:57:29,800
我就可以做很多很多事情

1832
00:57:29,800 --> 00:57:30,900
比如说举个例子

1833
00:57:30,900 --> 00:57:31,700
对吧

1834
00:57:32,533 --> 00:57:34,533
通常进程 a 的东西

1835
00:57:34,533 --> 00:57:36,766
不知道进程 b 的窗口的内容吧

1836
00:57:36,966 --> 00:57:37,400
对吧

1837
00:57:37,400 --> 00:57:40,133
这是正常情况之下你是不可能做到的

1838
00:57:40,133 --> 00:57:40,466
比如说

1839
00:57:40,466 --> 00:57:42,600
微信是不可能知道钉钉里面的东西的

1840
00:57:43,100 --> 00:57:44,933
但是呢合成剂就知道了

1841
00:57:44,933 --> 00:57:46,700
因为合成剂是带有特权的

1842
00:57:46,766 --> 00:57:47,566
它把这些东西呢

1843
00:57:47,566 --> 00:57:49,966
全都放到自己进程地址空间里面

1844
00:57:49,966 --> 00:57:51,300
然后就把这些东西呢

1845
00:57:51,500 --> 00:57:52,466
通过合成

1846
00:57:52,766 --> 00:57:55,166
合成呢就可以做半透明啊

1847
00:57:55,166 --> 00:57:56,466
什么 overlay

1848
00:57:56,466 --> 00:58:00,533
或者是模糊，圆角，透明

1849
00:58:00,533 --> 00:58:01,800
什么所有的阴影

1850
00:58:01,800 --> 00:58:03,266
这些东西全都可以实现了

1851
00:58:03,266 --> 00:58:04,266
这个时候呢就是

1852
00:58:04,266 --> 00:58:06,966
这个东西就起了关键性的作用

1853
00:58:06,966 --> 00:58:07,633
fd 

1854
00:58:07,633 --> 00:58:08,800
那也就是说

1855
00:58:08,800 --> 00:58:10,800
实际上现代的很多这个

1856
00:58:10,966 --> 00:58:12,533
复杂一点的系统软件

1857
00:58:12,833 --> 00:58:16,200
就会用到 memfd_create 这个函数

1858
00:58:16,800 --> 00:58:17,833
然后呢

1859
00:58:17,833 --> 00:58:18,900
还有其它配合

1860
00:58:18,900 --> 00:58:21,166
比如说 DRM 这样的一些这个

1861
00:58:21,366 --> 00:58:23,800
Direct Rendering 的这样一些模型

1862
00:58:23,800 --> 00:58:25,333
然后有了这些模型之后呢

1863
00:58:25,333 --> 00:58:27,200
你就会拿到这个 

1864
00:58:27,200 --> 00:58:27,933
frame buffer

1865
00:58:28,166 --> 00:58:30,633
frame buffer 这个帧缓冲区

1866
00:58:30,633 --> 00:58:32,366
或者是一个 buffer orbject

1867
00:58:32,366 --> 00:58:34,966
然后这些 buffer 我这边都有对应的 fd

1868
00:58:35,033 --> 00:58:36,200
然后把这些 fd 呢

1869
00:58:36,200 --> 00:58:39,366
你传到你希望传的那个进程里边

1870
00:58:39,366 --> 00:58:40,000
那个进程呢

1871
00:58:40,000 --> 00:58:42,666
就可以 mmap 到自己的进程地址空间里面

1872
00:58:42,666 --> 00:58:44,766
然后它就可以干什么呢

1873
00:58:44,766 --> 00:58:46,833
你甚至可以去修改那个内容

1874
00:58:46,833 --> 00:58:47,233
是吧

1875
00:58:47,233 --> 00:58:50,433
比如说前面上面加一个什么 frame

1876
00:58:50,433 --> 00:58:53,233
什么 FPS 等于多少多少之类

1877
00:58:53,266 --> 00:58:54,200
对吧

1878
00:58:54,533 --> 00:58:55,333
这就是这样

1879
00:58:55,433 --> 00:58:59,933
那刘博说的屏幕抓词软件不是这样的实现机制

1880
00:59:00,166 --> 00:59:01,833
屏幕抓词软件实现的机制

1881
00:59:01,866 --> 00:59:03,066
跟这个机制不一样

1882
00:59:03,133 --> 00:59:05,166
屏幕抓词软件早先在 Windows 里面

1883
00:59:05,166 --> 00:59:06,166
它的实现机制呢

1884
00:59:06,166 --> 00:59:07,666
实际上是做了一个勾子

1885
00:59:07,733 --> 00:59:08,900
就把那个 textout

1886
00:59:08,900 --> 00:59:11,033
或者 drawtext 那个系统的函数

1887
00:59:11,333 --> 00:59:12,033
做了个勾子

1888
00:59:12,033 --> 00:59:13,433
然后替换掉

1889
00:59:13,433 --> 00:59:14,266
然后呢这个时候呢

1890
00:59:14,266 --> 00:59:15,666
它会调用这个函数的时候

1891
00:59:15,666 --> 00:59:17,200
就会传入那个文本嘛

1892
00:59:17,200 --> 00:59:18,766
那我知道那个文本的位置

1893
00:59:18,766 --> 00:59:20,000
然后呢那个什么的时候

1894
00:59:20,033 --> 00:59:22,866
我就可以去知道啊

1895
00:59:22,866 --> 00:59:24,033
你显示的文本是啥

1896
00:59:24,033 --> 00:59:26,433
然后我再给你贴出来一个翻译完的

1897
00:59:26,433 --> 00:59:27,800
比如说一个单词啊

1898
00:59:27,866 --> 00:59:29,166
翻译完的这个中文

1899
00:59:29,333 --> 00:59:31,000
然后创建一个悬浮窗口

1900
00:59:31,000 --> 00:59:32,366
它是那么实现的啊

1901
00:59:33,000 --> 00:59:33,800
好

1902
00:59:35,200 --> 00:59:37,033
好了我们接下来一个问题啊

1903
00:59:37,033 --> 00:59:39,233
就是大块连续的虚拟内存

1904
00:59:39,366 --> 00:59:41,366
对应的物理内存是否连续

1905
00:59:41,366 --> 00:59:42,966
不确定是否连续

1906
00:59:43,066 --> 00:59:44,900
通常是不会连续

1907
00:59:44,900 --> 00:59:45,966
通常是不会连续

1908
00:59:46,600 --> 00:59:47,533
对，可能连续

1909
00:59:47,533 --> 00:59:48,500
也可能不连续

1910
00:59:48,500 --> 00:59:50,100
但大概率是不连续的

1911
00:59:50,300 --> 00:59:52,966
就比如说我通过 mmap 和 memfd

1912
00:59:53,100 --> 00:59:54,733
创大块连续的虚拟内存

1913
00:59:54,733 --> 00:59:56,366
对应的物理内存是否连续

1914
00:59:56,600 --> 00:59:58,000
准确来讲是不确定

1915
00:59:58,133 --> 00:59:59,600
就是说不一定连续

1916
00:59:59,600 --> 01:00:01,533
但是大概率是不连续的啊

1917
01:00:01,533 --> 01:00:02,333
因为你想啊

1918
01:00:02,333 --> 01:00:03,333
物理内存嘛

1919
01:00:03,333 --> 01:00:05,833
物理内存就是不停地频繁的在使用

1920
01:00:06,266 --> 01:00:08,233
然后呢一会这个进程退出

1921
01:00:08,233 --> 01:00:09,800
那释放了一堆的物理内存

1922
01:00:09,800 --> 01:00:11,633
它一定是非常非常什么

1923
01:00:11,633 --> 01:00:13,166
非常非常碎的

1924
01:00:13,433 --> 01:00:15,966
就是我们接下来会讲堆的这个碎片化

1925
01:00:16,033 --> 01:00:17,566
它一定是非常非常碎的

1926
01:00:17,566 --> 01:00:17,966
对吧

1927
01:00:17,966 --> 01:00:19,800
也是正因为这个原因

1928
01:00:19,800 --> 01:00:21,633
所以呢现在约定俗成

1929
01:00:21,633 --> 01:00:24,166
都是以 4K 为单位去管理它

1930
01:00:24,166 --> 01:00:26,466
但是在 4K 内它肯定是连续的

1931
01:00:26,600 --> 01:00:27,133
但是呢

1932
01:00:27,133 --> 01:00:30,433
比如说我分配了 1024K 的这个大内存

1933
01:00:30,966 --> 01:00:33,233
一共是 1024 除以 4

1934
01:00:33,233 --> 01:00:35,300
应该是 256 个 page

1935
01:00:35,300 --> 01:00:35,666
是吧

1936
01:00:35,733 --> 01:00:38,300
这 256 个 page 在物理内存里边

1937
01:00:38,566 --> 01:00:40,533
它没办法保证连续

1938
01:00:40,866 --> 01:00:42,133
如果你保证连续

1939
01:00:42,133 --> 01:00:43,733
那一定会什么

1940
01:00:44,066 --> 01:00:45,000
很容易失败

1941
01:00:45,200 --> 01:00:46,566
那这个分配很容易失败

1942
01:00:46,866 --> 01:00:47,800
很容易失败

1943
01:00:47,800 --> 01:00:51,633
GPU 里边我分配的 buffer 通常是连续的

1944
01:00:51,633 --> 01:00:52,100
这个呢

1945
01:00:52,100 --> 01:00:54,433
是因为 GPU 它希望那些东西是连续的

1946
01:00:54,433 --> 01:00:56,366
这样的话 GPU 操作起来方便

1947
01:00:56,666 --> 01:00:58,433
因为 GPU 内存也够多嘛

1948
01:00:58,433 --> 01:00:58,900
对吧

1949
01:00:58,900 --> 01:00:59,666
但是呢

1950
01:00:59,666 --> 01:01:00,633
你说 frame buffer

1951
01:01:00,633 --> 01:01:03,166
frame buffer 有的时候它就是在系统内存里边

1952
01:01:03,666 --> 01:01:04,166
这个时候呢

1953
01:01:04,166 --> 01:01:06,266
它的内容也不一定是连续

1954
01:01:06,266 --> 01:01:06,900
而且有的时候

1955
01:01:06,900 --> 01:01:09,400
它还会带有 catch 

1956
01:01:09,400 --> 01:01:10,600
什么之类的一些东西

1957
01:01:10,700 --> 01:01:12,566
那是如果是 GPU 里面的帧缓冲区

1958
01:01:12,566 --> 01:01:16,933
直接映射到这个系统的地址空间里边

1959
01:01:16,933 --> 01:01:18,266
那个时候是连续的

1960
01:01:18,266 --> 01:01:20,566
但是 frame buffer 本身它可以是假的

1961
01:01:22,400 --> 01:01:24,233
所以呢这个时候呢也是不连续的

1962
01:01:24,433 --> 01:01:26,633
分配算法是不是会尽可能连续

1963
01:01:26,666 --> 01:01:28,966
不会

1964
01:01:28,966 --> 01:01:30,966
它没必要去保证这一点

1965
01:01:30,966 --> 01:01:31,966
如果保证这一点

1966
01:01:31,966 --> 01:01:33,866
反到把这个事情变复杂了

1967
01:01:33,866 --> 01:01:34,700
因为我们都知道

1968
01:01:34,700 --> 01:01:36,866
就是虚拟内存和物理内存之间

1969
01:01:36,866 --> 01:01:38,033
它是通过什么呢

1970
01:01:38,066 --> 01:01:39,366
通过那个页表嘛

1971
01:01:39,366 --> 01:01:40,766
页表来翻译的

1972
01:01:40,766 --> 01:01:42,300
页表的翻译是谁干的呢

1973
01:01:42,300 --> 01:01:44,466
是 MMU，硬件来干的

1974
01:01:44,800 --> 01:01:45,166
对吧

1975
01:01:45,166 --> 01:01:46,466
那既然是硬件干

1976
01:01:46,466 --> 01:01:48,400
那我管它连续不连续

1977
01:01:48,400 --> 01:01:50,000
它都可以正常的翻译

1978
01:01:50,000 --> 01:01:51,500
我连续它也不会快一点

1979
01:01:51,500 --> 01:01:52,900
不连续它也不会慢一点

1980
01:01:53,233 --> 01:01:53,633
对吧

1981
01:01:53,633 --> 01:01:54,633
所以的话呢

1982
01:01:54,866 --> 01:01:56,633
你如果非要保证连续

1983
01:01:57,033 --> 01:01:58,833
软件实际上要做更多的事情

1984
01:01:59,066 --> 01:02:00,633
对，映射是硬件干的

1985
01:02:00,700 --> 01:02:03,966
那这个问题就是大家都懂了啊

1986
01:02:04,133 --> 01:02:05,533
好，我们接下来就讲这个

1987
01:02:05,533 --> 01:02:07,666
最简单的堆管理算法

1988
01:02:08,400 --> 01:02:10,033
这个实际上我在预习的时候

1989
01:02:10,033 --> 01:02:11,000
跟大家讲过

1990
01:02:11,000 --> 01:02:11,833
就是什么呢

1991
01:02:12,066 --> 01:02:14,633
就是我们设想一个啊

1992
01:02:14,633 --> 01:02:15,933
最简单的堆管理算法

1993
01:02:15,933 --> 01:02:16,633
那这个东西呢

1994
01:02:16,633 --> 01:02:18,500
我们先简化一下它的问题啊

1995
01:02:18,733 --> 01:02:19,533
简化到哪呢

1996
01:02:19,533 --> 01:02:21,500
就是说我先呢

1997
01:02:21,500 --> 01:02:24,400
就是给大家一个 1M 的空间

1998
01:02:24,400 --> 01:02:26,200
然后呢你就给我分配内存

1999
01:02:26,633 --> 01:02:28,833
我就调 malloc

2000
01:02:29,233 --> 01:02:31,700
然后呢这个随便给你传

2001
01:02:31,700 --> 01:02:32,866
当然了比如说 1M

2002
01:02:32,866 --> 01:02:34,033
1M 的这个堆

2003
01:02:34,333 --> 01:02:35,400
就是 1M

2004
01:02:35,400 --> 01:02:36,433
这么大的一个东西

2005
01:02:36,433 --> 01:02:38,800
0-1MB

2006
01:02:39,066 --> 01:02:41,933
当然了这个如果是固定大小的一个堆

2007
01:02:42,100 --> 01:02:43,433
然后让你去分配的时候

2008
01:02:43,433 --> 01:02:44,600
如果你传个 2M

2009
01:02:44,600 --> 01:02:46,233
你肯定返回失败

2010
01:02:46,566 --> 01:02:47,800
我们先简单的说一下

2011
01:02:47,800 --> 01:02:49,266
这个堆的这个算法

2012
01:02:49,266 --> 01:02:52,066
堆的这个算法我不知道大家有没有

2013
01:02:52,066 --> 01:02:55,700
想到这个可能的一个最简单的堆的管理方法

2014
01:02:55,700 --> 01:02:56,633
就是变长的

2015
01:02:56,633 --> 01:03:00,133
我极可能分配一个字节

2016
01:03:00,133 --> 01:03:02,100
也可能分配两个字节

2017
01:03:02,100 --> 01:03:04,666
也可能分配 128K

2018
01:03:05,000 --> 01:03:08,233
也可能分配比如说是 512  字节

2019
01:03:08,400 --> 01:03:09,800
反正就是变长的

2020
01:03:10,000 --> 01:03:13,133
那我们怎么去管理它

2021
01:03:13,300 --> 01:03:14,866
最简单的一个算法

2022
01:03:14,866 --> 01:03:17,566
我不知道有没有人去思考过这个问题

2023
01:03:17,866 --> 01:03:19,200
因为这是我安排的

2024
01:03:19,200 --> 01:03:20,800
预习的时候大家预习的

2025
01:03:20,866 --> 01:03:22,033
有没有人去思考过

2026
01:03:22,500 --> 01:03:24,633
哎呀，刘博还是脑子快

2027
01:03:24,700 --> 01:03:25,833
不愧是博士

2028
01:03:26,033 --> 01:03:27,433
对没错啊

2029
01:03:27,600 --> 01:03:30,600
这个呢实际上就叫做 buddy 分配器

2030
01:03:30,600 --> 01:03:32,000
在 Linux 内核里边

2031
01:03:32,000 --> 01:03:34,600
用它来管理物理内存的页

2032
01:03:34,933 --> 01:03:36,833
buddy 分配器是什么呢

2033
01:03:37,000 --> 01:03:37,533
就是说

2034
01:03:38,400 --> 01:03:41,900
我先它分成什么相等的

2035
01:03:42,600 --> 01:03:43,733
这样的几个区域

2036
01:03:44,833 --> 01:03:45,900
然后呢这里边呢

2037
01:03:45,900 --> 01:03:50,400
我用 2 为单位把它分开

2038
01:03:54,666 --> 01:03:55,333
对吧

2039
01:03:55,333 --> 01:03:56,233
比如说举个例子

2040
01:03:56,233 --> 01:03:58,266
1234567

2041
01:03:58,900 --> 01:04:00,100
8 个吧

2042
01:04:01,233 --> 01:04:02,033
8 个

2043
01:04:02,100 --> 01:04:04,033
然后呢这个是第一

2044
01:04:04,033 --> 01:04:05,633
这是2为单位

2045
01:04:05,633 --> 01:04:07,133
然后呢这个以4为单位

2046
01:04:07,133 --> 01:04:08,600
这个以8为单位

2047
01:04:08,900 --> 01:04:10,866
248 然后呢

2048
01:04:10,866 --> 01:04:16,666
是163264 呃 128512

2049
01:04:18,033 --> 01:04:18,733
那这个时候呢

2050
01:04:18,733 --> 01:04:21,200
512 的肯定只能分配两个嘛

2051
01:04:21,200 --> 01:04:21,500
对吧

2052
01:04:21,500 --> 01:04:22,666
但是 128 的呢

2053
01:04:22,666 --> 01:04:24,000
我可以分配 4 个

2054
01:04:24,200 --> 01:04:25,133
然后 64 的呢

2055
01:04:25,133 --> 01:04:26,633
我就可以分配什么呢

2056
01:04:26,833 --> 01:04:27,666
分配这么多

2057
01:04:29,300 --> 01:04:30,466
然后呢

2058
01:04:30,466 --> 01:04:31,700
就是这样子啊

2059
01:04:31,700 --> 01:04:33,500
这个图可以这么画啊

2060
01:04:46,633 --> 01:04:47,400
这样子的话呢

2061
01:04:47,400 --> 01:04:50,500
我是看你要求我分配

2062
01:04:50,500 --> 01:04:53,266
比如说 1，1 个字节大小的

2063
01:04:53,266 --> 01:04:56,500
我就从这里面给你找一块返回给你

2064
01:04:58,700 --> 01:05:01,866
如果我要分配三个字节的

2065
01:05:01,866 --> 01:05:04,633
比 2 大，那我就从这里面给你找一个

2066
01:05:04,633 --> 01:05:05,333
对吧

2067
01:05:06,033 --> 01:05:08,000
如果呢是分配什么呢

2068
01:05:08,000 --> 01:05:10,666
分配比如说是 512 字节的

2069
01:05:11,600 --> 01:05:12,233
那我怎么呢

2070
01:05:12,233 --> 01:05:13,900
我就从这里边

2071
01:05:13,900 --> 01:05:16,900
或者大于 128 小于 512

2072
01:05:16,900 --> 01:05:18,433
我就从这里边给你分

2073
01:05:18,866 --> 01:05:19,333
对吧

2074
01:05:19,333 --> 01:05:20,900
这个就叫做什么呢

2075
01:05:20,900 --> 01:05:22,400
就是一个基本的

2076
01:05:22,400 --> 01:05:23,300
简单的一个

2077
01:05:23,300 --> 01:05:26,266
叫做 buddy 分配器去分配

2078
01:05:26,266 --> 01:05:27,000
分配的

2079
01:05:27,000 --> 01:05:29,966
那为了维护我们这些东西的

2080
01:05:29,966 --> 01:05:31,100
它的分配状态

2081
01:05:31,100 --> 01:05:32,033
我在这边呢

2082
01:05:32,033 --> 01:05:33,433
可以用一个位图

2083
01:05:36,033 --> 01:05:37,433
就比如说举个例子

2084
01:05:37,566 --> 01:05:38,466
这个里边的话呢

2085
01:05:38,466 --> 01:05:39,300
我用啥呢

2086
01:05:39,666 --> 01:05:41,166
用 2 个字节

2087
01:05:41,300 --> 01:05:42,600
就两个位

2088
01:05:43,000 --> 01:05:43,600
但实质上呢

2089
01:05:43,600 --> 01:05:46,233
我可以把它再变成最低的

2090
01:05:46,233 --> 01:05:47,866
这个呢是一共是 8 个

2091
01:05:47,866 --> 01:05:48,266
这样的话

2092
01:05:48,266 --> 01:05:49,633
我用 8 个一个位

2093
01:05:49,666 --> 01:05:52,200
一个 B 来表示它的分配状态

2094
01:05:52,233 --> 01:05:54,766
比如说这个置 1 表示它已经被分配了

2095
01:05:54,900 --> 01:05:55,633
这个置 1 呢

2096
01:05:55,633 --> 01:05:57,666
表示第二个被分配了

2097
01:05:58,100 --> 01:06:00,266
然后再往下那就是 2 个 B

2098
01:06:01,800 --> 01:06:02,500
所有的东西呢

2099
01:06:02,500 --> 01:06:03,966
它都有维护的什么呢

2100
01:06:03,966 --> 01:06:04,833
维护的成本

2101
01:06:04,833 --> 01:06:06,600
那这个就是维护的成本

2102
01:06:06,800 --> 01:06:07,833
1B 2B

2103
01:06:07,833 --> 01:06:14,100
1，2，4，8，16，32，64，128

2104
01:06:14,266 --> 01:06:16,433
那这个是 128B

2105
01:06:16,666 --> 01:06:18,466
然后 128 个 Byte 里边呢

2106
01:06:18,466 --> 01:06:20,633
每一位对应于什么呢

2107
01:06:20,833 --> 01:06:22,866
对应于其中的一个

2108
01:06:22,866 --> 01:06:25,833
对应于其中的一个东西的分配的状态

2109
01:06:26,000 --> 01:06:27,433
用 0 表示没分配

2110
01:06:27,433 --> 01:06:28,633
用 1 表示已分配

2111
01:06:29,200 --> 01:06:30,500
然后在这种情况之下呢

2112
01:06:30,500 --> 01:06:32,033
我们就非常容易的

2113
01:06:32,033 --> 01:06:33,500
就可以去分配内存了

2114
01:06:33,500 --> 01:06:35,433
而且这种分配方式的话呢

2115
01:06:35,433 --> 01:06:37,266
存在一个好处是什么呢

2116
01:06:37,800 --> 01:06:38,800
没有碎片化

2117
01:06:39,200 --> 01:06:40,666
你能分配到就是能分配到

2118
01:06:40,666 --> 01:06:42,300
分配不到就是分配不到

2119
01:06:42,300 --> 01:06:42,633
是吧

2120
01:06:42,633 --> 01:06:43,466
没有碎片化

2121
01:06:43,466 --> 01:06:45,300
但是它有一个坏处是什么

2122
01:06:45,766 --> 01:06:46,766
内存有浪费

2123
01:06:47,000 --> 01:06:48,433
内存呢是有浪费的

2124
01:06:48,433 --> 01:06:50,133
就比如说我在这里面

2125
01:06:50,133 --> 01:06:52,633
分配啊这里边写错了 512

2126
01:06:52,633 --> 01:06:54,000
这 256

2127
01:06:55,200 --> 01:06:58,133
128 我要分配 129 的时候呢

2128
01:06:58,133 --> 01:06:59,833
你就得在这里边分配

2129
01:07:00,100 --> 01:07:01,166
但是这个空间呢

2130
01:07:01,166 --> 01:07:03,366
你一次占了 256

2131
01:07:03,366 --> 01:07:06,500
它就是这样子的一个不好的地方

2132
01:07:06,500 --> 01:07:09,633
就是它存在这样一个问题啊

2133
01:07:09,700 --> 01:07:11,300
那这种算法啊

2134
01:07:11,533 --> 01:07:12,500
还有一个不足

2135
01:07:12,500 --> 01:07:13,200
不足是什么呢

2136
01:07:13,200 --> 01:07:13,866
就比如说

2137
01:07:13,866 --> 01:07:16,100
你不整个可能是 1MB 吗

2138
01:07:16,200 --> 01:07:18,766
我分配比如说是 512K

2139
01:07:18,966 --> 01:07:20,466
那就是 1M 的一半

2140
01:07:20,666 --> 01:07:22,433
这个东西也没法 work

2141
01:07:22,433 --> 01:07:24,433
也没法 work

2142
01:07:24,666 --> 01:07:27,533
就是它存在很多很多很多限制

2143
01:07:27,533 --> 01:07:28,966
但是它有它的优点

2144
01:07:28,966 --> 01:07:30,166
速度快

2145
01:07:30,166 --> 01:07:31,766
因为我知道这个大小之后呢

2146
01:07:31,766 --> 01:07:34,933
我就可以很容易的去找着一个空的

2147
01:07:34,933 --> 01:07:36,600
然后呢把它给分配给你

2148
01:07:37,266 --> 01:07:39,400
然后呢还没有碎片化的问题

2149
01:07:40,366 --> 01:07:41,366
那坏处是什么呢

2150
01:07:41,366 --> 01:07:43,133
就是大块的

2151
01:07:43,533 --> 01:07:44,466
它没法分配

2152
01:07:45,166 --> 01:07:47,533
另外呢就是内存有浪费啊

2153
01:07:47,533 --> 01:07:48,533
有浪费

2154
01:07:48,533 --> 01:07:50,133
这是它的一个问题

2155
01:07:50,833 --> 01:07:52,233
那还有还有什么

2156
01:07:52,233 --> 01:07:54,400
当然我们在 malloc 这个

2157
01:07:54,400 --> 01:07:55,800
这个就是系统

2158
01:07:55,966 --> 01:07:56,966
C 库里边

2159
01:07:56,966 --> 01:07:58,333
就是堆的这个 C 库里边

2160
01:07:58,333 --> 01:07:59,166
它的这个算法

2161
01:07:59,166 --> 01:08:01,333
一定要比这个复杂的多

2162
01:08:01,333 --> 01:08:01,766
复杂的多

2163
01:08:01,766 --> 01:08:04,000
我们待会大概给大家解释一下

2164
01:08:04,066 --> 01:08:06,766
我们现在再来看内核的 slab 分配器

2165
01:08:07,000 --> 01:08:08,533
内核的 slab 分配器呢

2166
01:08:08,533 --> 01:08:10,566
它呢提供了一个什么呢

2167
01:08:10,566 --> 01:08:12,666
特别好的一个优化啊

2168
01:08:12,666 --> 01:08:14,100
是因为是这样子的

2169
01:08:14,100 --> 01:08:16,900
在内核里边有很多数据结构

2170
01:08:17,000 --> 01:08:18,300
它大小是一样的

2171
01:08:18,533 --> 01:08:19,166
就比如说

2172
01:08:19,166 --> 01:08:21,733
我要表示一个文件的那个数据结构

2173
01:08:21,733 --> 01:08:22,266
files

2174
01:08:22,266 --> 01:08:24,500
 open the files structure

2175
01:08:24,700 --> 01:08:28,200
它这个结构一般不就是我们用那个

2176
01:08:29,166 --> 01:08:31,233
就是 structure 定义的吗

2177
01:08:31,366 --> 01:08:32,900
那这些结构肯定是一样的

2178
01:08:32,900 --> 01:08:34,533
而且你想

2179
01:08:34,533 --> 01:08:36,900
每一个进程打开那个

2180
01:08:36,900 --> 01:08:37,966
最初打开

2181
01:08:37,966 --> 01:08:39,200
都得打开 3 个吧

2182
01:08:39,200 --> 01:08:41,700
啊打开 3 个文件描述符

2183
01:08:41,966 --> 01:08:44,700
那它对应的那些文件

2184
01:08:45,000 --> 01:08:47,033
包括很多进程都会有打开文件

2185
01:08:47,033 --> 01:08:47,633
关闭文件

2186
01:08:47,633 --> 01:08:48,166
打开文件

2187
01:08:48,166 --> 01:08:49,600
它要有很多很多

2188
01:08:49,600 --> 01:08:50,133
也就是说

2189
01:08:50,133 --> 01:08:51,233
它在系统里面

2190
01:08:51,400 --> 01:08:55,366
会有很多同时存在的这个文件

2191
01:08:55,566 --> 01:08:56,633
打开的文件结构

2192
01:08:57,166 --> 01:08:57,533
对吧

2193
01:08:57,533 --> 01:09:01,233
这是一种很常见的一个情况

2194
01:09:01,700 --> 01:09:05,600
那为了我去管理这些结构

2195
01:09:07,333 --> 01:09:08,433
那我有什么办法呢

2196
01:09:08,433 --> 01:09:11,066
就是所谓的 slab 分配器

2197
01:09:11,066 --> 01:09:12,000
也就是说

2198
01:09:12,000 --> 01:09:15,333
我专门给开辟出一块空间来

2199
01:09:15,333 --> 01:09:17,566
专门保存这些文件

2200
01:09:17,633 --> 01:09:19,566
统一的地方保存这些文件

2201
01:09:19,600 --> 01:09:21,366
你需要的时候就在这儿取

2202
01:09:21,700 --> 01:09:22,900
那就简单了

2203
01:09:22,900 --> 01:09:23,666
为什么？

2204
01:09:23,666 --> 01:09:25,733
它是固定大小结构

2205
01:09:26,500 --> 01:09:27,966
也就比如说这个结构啊

2206
01:09:27,966 --> 01:09:28,966
一个结构呢

2207
01:09:29,100 --> 01:09:30,833
比如说是刚好是 64 字节

2208
01:09:32,366 --> 01:09:33,866
刚好是 64 字节

2209
01:09:33,866 --> 01:09:35,633
我放在一个页里边

2210
01:09:35,633 --> 01:09:37,066
4K 的一个页里边

2211
01:09:37,133 --> 01:09:39,366
那就是可以密密麻麻的保存它呀

2212
01:09:40,333 --> 01:09:40,600
对吧

2213
01:09:40,600 --> 01:09:42,533
我就可以密密麻麻的保存它呀

2214
01:09:43,833 --> 01:09:44,400
这样的话呢

2215
01:09:44,400 --> 01:09:45,266
就很容易

2216
01:09:45,266 --> 01:09:48,100
我找一个没有被用的

2217
01:09:48,433 --> 01:09:50,033
然后呢或者是什么样子

2218
01:09:50,033 --> 01:09:53,233
我用一个双向链表就可以把它维护好

2219
01:09:53,766 --> 01:09:55,100
因为通常这些东西

2220
01:09:55,100 --> 01:09:57,266
它本身就是在真正用的时候

2221
01:09:57,266 --> 01:09:58,966
它就有双向链表的

2222
01:09:59,100 --> 01:10:01,433
prev 和 next 那个指针

2223
01:10:01,533 --> 01:10:02,566
然后我把它

2224
01:10:02,900 --> 01:10:04,466
就是说把它 free

2225
01:10:04,466 --> 01:10:05,233
这些没用的

2226
01:10:05,233 --> 01:10:06,700
这些东西我维护起来的时候

2227
01:10:06,700 --> 01:10:08,666
也同样可以用这些指针

2228
01:10:09,133 --> 01:10:09,466
对吧

2229
01:10:09,466 --> 01:10:11,466
那我就可以维护一个什么呢

2230
01:10:11,466 --> 01:10:12,533
维护一个双向链表

2231
01:10:12,533 --> 01:10:13,266
把它们链起来

2232
01:10:13,266 --> 01:10:14,233
就是空闲的

2233
01:10:14,233 --> 01:10:15,300
我给它链起来

2234
01:10:15,300 --> 01:10:16,166
然后呢

2235
01:10:16,266 --> 01:10:18,133
我只需要保存一个

2236
01:10:18,500 --> 01:10:21,100
当前空闲的那个头指针

2237
01:10:21,300 --> 01:10:23,733
我就可以很快的拿到下一个了

2238
01:10:23,966 --> 01:10:24,500
空闲的

2239
01:10:24,500 --> 01:10:25,033
对不对

2240
01:10:25,033 --> 01:10:25,966
这多简单啊

2241
01:10:26,100 --> 01:10:26,900
是吧

2242
01:10:27,100 --> 01:10:30,100
然后呢我在需要去释放的时候

2243
01:10:30,100 --> 01:10:31,100
就把这个东西呢

2244
01:10:31,100 --> 01:10:33,633
再给它链到那个双向链表里面不就去了吗

2245
01:10:33,666 --> 01:10:36,200
那 Linux 底下有一个很经典的这个

2246
01:10:36,200 --> 01:10:38,633
双向链表的一个维护代码

2247
01:10:38,933 --> 01:10:40,500
这个呢就是 list.h

2248
01:10:40,500 --> 01:10:42,266
大家可能都知道，对吧

2249
01:10:42,266 --> 01:10:44,433
我们在 C 程序里面也经常用

2250
01:10:44,533 --> 01:10:45,533
非常方便

2251
01:10:45,533 --> 01:10:46,933
操作起来非常方便

2252
01:10:46,966 --> 01:10:49,066
这就是 slab 分配器

2253
01:10:49,066 --> 01:10:50,900
实际上 slab 分配器啊

2254
01:10:50,900 --> 01:10:52,833
给我们带来一个什么呢

2255
01:10:52,933 --> 01:10:55,133
带来一个就是启发

2256
01:10:55,233 --> 01:10:57,533
在我们做一些应用的时候

2257
01:10:57,866 --> 01:10:59,633
做一些自己编程序的时候

2258
01:10:59,633 --> 01:11:02,433
我们经常要去优化这个分配

2259
01:11:02,800 --> 01:11:03,633
那有的时候呢

2260
01:11:03,633 --> 01:11:06,433
我们就可以用 slab 这种方式

2261
01:11:06,433 --> 01:11:08,333
去分配和管理我自己的内存

2262
01:11:08,333 --> 01:11:09,866
尤其是大量的

2263
01:11:09,866 --> 01:11:12,200
有相同大小的这种数据结构

2264
01:11:12,200 --> 01:11:13,333
需要去分配的时候

2265
01:11:13,333 --> 01:11:15,000
我就用 slab 分配器

2266
01:11:15,266 --> 01:11:18,100
这样会提高这个系统的性能

2267
01:11:18,300 --> 01:11:19,966
就比说举个例子

2268
01:11:20,500 --> 01:11:23,400
像 JavaScript 这种编程语言里边

2269
01:11:23,400 --> 01:11:25,766
所有的这种变量对应的这个值

2270
01:11:25,966 --> 01:11:28,766
它一定是用一个同样的数据结构

2271
01:11:28,766 --> 01:11:29,900
来表示的

2272
01:11:29,900 --> 01:11:32,300
待会儿我给大家看我们 HVML 里边的

2273
01:11:32,300 --> 01:11:33,400
一样，都是一样

2274
01:11:33,400 --> 01:11:34,833
大家的设计思路都是一样的

2275
01:11:35,233 --> 01:11:37,800
然后呢也有很多这个字段

2276
01:11:37,833 --> 01:11:41,000
就是可以用来把它串成一个链表啊

2277
01:11:41,200 --> 01:11:42,200
那这个时候呢

2278
01:11:42,200 --> 01:11:44,233
我们就可以利用这些东西

2279
01:11:44,233 --> 01:11:45,566
把这些东西呢利用起来

2280
01:11:45,566 --> 01:11:47,766
然后我一开始的时候就给它

2281
01:11:47,766 --> 01:11:49,433
或者是我用的时候呢

2282
01:11:49,433 --> 01:11:49,933
我分配

2283
01:11:49,933 --> 01:11:50,466
但是呢

2284
01:11:50,466 --> 01:11:52,600
我不释放到系统里边去

2285
01:11:52,600 --> 01:11:54,533
因为大概率情况之下

2286
01:11:54,533 --> 01:11:55,433
你这些东西啊

2287
01:11:55,433 --> 01:11:55,766
还要

2288
01:11:56,000 --> 01:11:57,966
释放了之后还会再分配回来

2289
01:11:57,966 --> 01:11:59,966
那我干脆不给你释放了

2290
01:11:59,966 --> 01:12:01,666
不释放到系统

2291
01:12:02,266 --> 01:12:03,933
那下次用的时候我直接给你返回

2292
01:12:03,933 --> 01:12:05,866
就相当于增加了一级 cache

2293
01:12:05,866 --> 01:12:09,033
而不需要每一次都调用 malloc

2294
01:12:09,033 --> 01:12:11,533
大家不是很很讨厌那个内存碎片化吗

2295
01:12:11,533 --> 01:12:13,233
很害怕内存碎片化吗

2296
01:12:13,233 --> 01:12:16,300
这就是其中的一个解决方案

2297
01:12:16,600 --> 01:12:16,833
好

2298
01:12:16,833 --> 01:12:18,166
我们接下来看到这个

2299
01:12:18,166 --> 01:12:20,766
就是常见的内存的这个使用问题啊

2300
01:12:21,066 --> 01:12:21,600
那一个呢

2301
01:12:21,600 --> 01:12:23,200
就是 OOM

2302
01:12:23,200 --> 01:12:24,400
OOM 指什么呢

2303
01:12:24,400 --> 01:12:25,966
就是 Out Of Memory

2304
01:12:26,700 --> 01:12:28,466
然后呢还有不对齐访问

2305
01:12:28,900 --> 01:12:29,866
还有越界访问

2306
01:12:29,866 --> 01:12:30,933
或者非法指针

2307
01:12:30,933 --> 01:12:31,766
内存泄露

2308
01:12:31,866 --> 01:12:32,700
这些东西呢

2309
01:12:32,700 --> 01:12:34,933
都是我们通常说的

2310
01:12:35,133 --> 01:12:36,033
嘴里说的

2311
01:12:36,033 --> 01:12:39,033
但是呢真正的术语在这里

2312
01:12:39,033 --> 01:12:40,033
术语在这里

2313
01:12:40,233 --> 01:12:42,900
也就是说内存使用的这个问题啊

2314
01:12:42,900 --> 01:12:45,433
实际上内些搞编译器的

2315
01:12:45,700 --> 01:12:47,700
尤其是搞 C/C++ 编译器的那些人

2316
01:12:47,733 --> 01:12:49,266
早就给我们总结出来了

2317
01:12:49,433 --> 01:12:52,166
一共是十种

2318
01:12:52,666 --> 01:12:53,466
第一种问题呢

2319
01:12:53,466 --> 01:12:55,000
就是 use-after-free

2320
01:12:55,066 --> 01:12:57,466
就是你把这地址释放了

2321
01:12:57,700 --> 01:13:01,033
然后你还用

2322
01:13:01,300 --> 01:13:03,233
这个就叫 use-after-free

2323
01:13:03,466 --> 01:13:04,166
这种情况呢

2324
01:13:04,166 --> 01:13:06,366
它既可能导致程序是呃出错

2325
01:13:06,533 --> 01:13:08,500
也可能不会导致程序出错

2326
01:13:08,500 --> 01:13:09,600
这个呢不一定的

2327
01:13:10,066 --> 01:13:11,666
那还有 use-after-return

2328
01:13:11,666 --> 01:13:12,366
什么意思呢

2329
01:13:12,366 --> 01:13:14,333
就是说你返回一个地址

2330
01:13:14,333 --> 01:13:15,500
这个地址是什么呢

2331
01:13:15,500 --> 01:13:18,033
地址实际上是在栈帧里边的

2332
01:13:18,200 --> 01:13:19,200
就比如说举个例子啊

2333
01:13:19,200 --> 01:13:20,800
我在一个函数体里边

2334
01:13:21,266 --> 01:13:24,866
然后定义了一个 char p

2335
01:13:25,200 --> 01:13:29,000
这 char p 的这个就是一个字符串

2336
01:13:29,000 --> 01:13:30,700
缓冲区 10

2337
01:13:31,466 --> 01:13:32,000
然后呢

2338
01:13:32,000 --> 01:13:35,633
你把这个 p 给返回了，是吧

2339
01:13:35,866 --> 01:13:37,033
哎这这个呢

2340
01:13:37,033 --> 01:13:39,966
就是 use-after-return

2341
01:13:40,300 --> 01:13:42,600
然后呢还有一个叫 use-after-scope

2342
01:13:42,600 --> 01:13:44,733
指的是你超过这个区

2343
01:13:45,300 --> 01:13:45,800
超过区

2344
01:13:45,833 --> 01:13:47,033
这个什么意思呢

2345
01:13:47,033 --> 01:13:47,833
就是在这

2346
01:13:47,933 --> 01:13:49,566
给大家写个单函数啊

2347
01:13:50,200 --> 01:13:51,833
就是在函数体里边

2348
01:13:51,833 --> 01:13:52,533
大家都知道

2349
01:13:52,533 --> 01:13:57,733
用大括号可以定义一个局部的名字空间嘛

2350
01:13:57,733 --> 01:13:58,200
对吧

2351
01:13:58,400 --> 01:14:04,133
那比如说我 char buff [10];

2352
01:14:04,133 --> 01:14:04,933
10 然后呢

2353
01:14:04,933 --> 01:14:05,833
我在这里边呢

2354
01:14:05,833 --> 01:14:08,200
定义了一个 char* P

2355
01:14:08,733 --> 01:14:09,733
我在这里面呢

2356
01:14:09,733 --> 01:14:11,200
P = buff;

2357
01:14:12,400 --> 01:14:14,500
然后呢我在这里边用它

2358
01:14:16,200 --> 01:14:18,000
P[0] = 'A'

2359
01:14:19,533 --> 01:14:21,866
哎那这样的这个代码

2360
01:14:21,933 --> 01:14:24,100
就是 use-after-scope

2361
01:14:24,166 --> 01:14:25,233
什么意思呢

2362
01:14:25,600 --> 01:14:26,500
你看这个东西啊

2363
01:14:26,500 --> 01:14:29,566
它实际上是在这个这个里边 buffer

2364
01:14:29,566 --> 01:14:29,800
对吧

2365
01:14:29,800 --> 01:14:32,066
buffer 是在这个 scope 里边

2366
01:14:32,066 --> 01:14:34,033
就是这个范围里边

2367
01:14:34,266 --> 01:14:36,200
然后呢你 P=buff；

2368
01:14:36,633 --> 01:14:37,600
这个东西呢

2369
01:14:37,900 --> 01:14:38,966
scope 结束的时候

2370
01:14:38,966 --> 01:14:39,933
实际上这个 buffer

2371
01:14:39,933 --> 01:14:41,200
实际上这个栈帧啊

2372
01:14:41,200 --> 01:14:42,166
它有可能还在

2373
01:14:42,166 --> 01:14:43,033
有可能不在

2374
01:14:43,033 --> 01:14:45,033
这个跟编译器的具体实现有关

2375
01:14:45,100 --> 01:14:45,966
但大概率呢

2376
01:14:45,966 --> 01:14:46,833
会出错啊

2377
01:14:46,833 --> 01:14:47,833
大概率会出错

2378
01:14:47,833 --> 01:14:49,600
然后呢你在这里面通过 P

2379
01:14:49,600 --> 01:14:53,666
来试图访问这个 buffer 里的第0个字节

2380
01:14:53,833 --> 01:14:54,266
是吧

2381
01:14:54,666 --> 01:14:55,600
那就会出错

2382
01:14:55,600 --> 01:14:56,833
那这是第三种

2383
01:14:56,966 --> 01:14:57,666
第四种呢

2384
01:14:57,666 --> 01:15:00,066
就是 heap-buffer-overflow

2385
01:15:00,066 --> 01:15:02,133
或者是 heap-buffer-underflow

2386
01:15:02,133 --> 01:15:02,833
这个指什么呢

2387
01:15:02,833 --> 01:15:05,433
就是在 heep 里边访问

2388
01:15:05,833 --> 01:15:08,933
就比如说是我这个 buff[10] 是吧

2389
01:15:09,266 --> 01:15:12,233
然后呢我访问这个什么呢啊

2390
01:15:13,566 --> 01:15:15,200
buff 的第0个

2391
01:15:16,000 --> 01:15:17,500
比如说第 -1 个，是吧

2392
01:15:17,700 --> 01:15:20,700
或者是第 40 个

2393
01:15:20,966 --> 01:15:22,366
那么如果这个 buffer 呢

2394
01:15:22,366 --> 01:15:23,166
是 malloc 的

2395
01:15:23,166 --> 01:15:23,700
就是 heep

2396
01:15:24,033 --> 01:15:24,566
如果呢

2397
01:15:24,566 --> 01:15:25,800
是在栈里边的

2398
01:15:25,800 --> 01:15:26,466
那就是什么呢

2399
01:15:26,466 --> 01:15:27,166
就是 stack

2400
01:15:27,166 --> 01:15:27,900
就是底下的

2401
01:15:27,900 --> 01:15:30,700
stack-buffer-overflow/stack-buffer-underflow

2402
01:15:30,833 --> 01:15:31,400
然后呢

2403
01:15:31,400 --> 01:15:33,966
global-buffer-overflow/global-buffer-underflow

2404
01:15:33,966 --> 01:15:34,566
指什么呢

2405
01:15:34,566 --> 01:15:35,733
就是全局变量

2406
01:15:35,800 --> 01:15:37,100
你针对全局变量

2407
01:15:37,100 --> 01:15:39,700
比如说我在这里边设了一个 static

2408
01:15:39,700 --> 01:15:41,100
static 这样的东西

2409
01:15:41,100 --> 01:15:43,366
然后呢你用这种方式去访问

2410
01:15:43,366 --> 01:15:45,166
超越界就是所谓的越界

2411
01:15:45,166 --> 01:15:46,500
实际上细分起来的话呢

2412
01:15:46,500 --> 01:15:48,200
一共有六种情况啊

2413
01:15:48,300 --> 01:15:50,066
然后再往下就是 double-free

2414
01:15:50,066 --> 01:15:50,733
double-free 是什么呢

2415
01:15:50,733 --> 01:15:52,500
就是你 free 完的指针

2416
01:15:52,500 --> 01:15:53,866
你又一次 free 嘛

2417
01:15:53,866 --> 01:15:54,600
实际上就很简单

2418
01:15:54,600 --> 01:15:56,666
因为 free 呀，malloc

2419
01:15:56,666 --> 01:15:57,133
尤其 free

2420
01:15:57,133 --> 01:15:59,466
它不会去检查这个指针的这个

2421
01:15:59,466 --> 01:16:01,500
你传的这个指针的有效性

2422
01:16:01,666 --> 01:16:03,766
然后呢它就拿这个指针开始操作了

2423
01:16:03,766 --> 01:16:04,800
一操作，完蛋了

2424
01:16:04,800 --> 01:16:06,533
你这个缓冲区

2425
01:16:06,666 --> 01:16:09,200
或者你的堆的结构就要被破坏掉

2426
01:16:09,400 --> 01:16:10,700
那还有就是 memory leaks

2427
01:16:10,700 --> 01:16:11,700
memory leaks 是什么

2428
01:16:11,700 --> 01:16:13,000
你不停的分配内存

2429
01:16:13,000 --> 01:16:14,666
但是呢你从来不释放内存

2430
01:16:14,666 --> 01:16:16,000
那就是 memory leaks

2431
01:16:16,000 --> 01:16:17,500
就是内存泄露

2432
01:16:17,500 --> 01:16:18,233
还有一种呢

2433
01:16:18,233 --> 01:16:21,333
叫做 Initialization order bugs

2434
01:16:21,333 --> 01:16:22,066
这个指什么呢

2435
01:16:22,066 --> 01:16:23,933
就是有多个全局变量

2436
01:16:24,066 --> 01:16:26,166
在不同的这个文件里面的时候

2437
01:16:26,266 --> 01:16:28,533
你可能因为这种初始化的

2438
01:16:28,533 --> 01:16:31,666
这个就是顺序问题

2439
01:16:31,666 --> 01:16:32,833
导致一些缺陷啊

2440
01:16:32,833 --> 01:16:34,000
这个很少见啊

2441
01:16:34,000 --> 01:16:35,500
现在的程序员很少见

2442
01:16:35,566 --> 01:16:36,833
但是有些情况之下

2443
01:16:36,833 --> 01:16:38,033
它会比较啊

2444
01:16:38,033 --> 01:16:38,833
比较重要

2445
01:16:39,333 --> 01:16:41,066
所以呢为了这些问题啊

2446
01:16:41,133 --> 01:16:42,266
出现这些问题的时候

2447
01:16:42,266 --> 01:16:43,533
我们怎么办啊

2448
01:16:43,533 --> 01:16:43,966
怎么办

2449
01:16:44,066 --> 01:16:46,733
就是说我们要大概会知道啊

2450
01:16:46,733 --> 01:16:48,233
就是内存使用问题

2451
01:16:48,233 --> 01:16:50,566
通常会表现出来哪些现象

2452
01:16:50,566 --> 01:16:52,200
也就是说我们如何去诊断

2453
01:16:52,233 --> 01:16:53,200
就比如说越界访问

2454
01:16:53,200 --> 01:16:55,366
或者非法地址导致的现象

2455
01:16:55,366 --> 01:16:57,566
就是你这个程序会 segment fault

2456
01:16:57,866 --> 01:16:59,566
就 SEGV

2457
01:16:59,566 --> 01:17:03,233
就会收到这个 SEGV 的这个信号

2458
01:17:03,633 --> 01:17:04,433
对吧

2459
01:17:05,333 --> 01:17:05,866
那通常呢

2460
01:17:05,866 --> 01:17:06,533
就是 SEGV

2461
01:17:06,533 --> 01:17:08,866
就表示你这个内存是有那个什么了

2462
01:17:09,333 --> 01:17:12,400
然后呢另外一种叫不对齐访问

2463
01:17:12,400 --> 01:17:14,400
不对齐访问呢会导致什么呢

2464
01:17:14,733 --> 01:17:16,833
导致 bus error

2465
01:17:17,266 --> 01:17:18,633
EBus

2466
01:17:18,633 --> 01:17:20,666
就是 bus error 总线错误

2467
01:17:20,866 --> 01:17:23,333
这个我特别给大家解释一下

2468
01:17:23,333 --> 01:17:24,833
什么叫不对齐

2469
01:17:25,100 --> 01:17:25,633
不对齐

2470
01:17:25,633 --> 01:17:27,333
就比如说举个例子

2471
01:17:27,533 --> 01:17:34,200
我们给了一个 char buff[10]

2472
01:17:34,733 --> 01:17:36,600
然后呢我通常啊

2473
01:17:36,600 --> 01:17:40,033
这个 buffer 它是以字节为单位嘛

2474
01:17:40,033 --> 01:17:41,766
所以呢系统呢

2475
01:17:41,766 --> 01:17:43,200
给它分配内存的时候

2476
01:17:43,200 --> 01:17:45,466
它只需要一个字节为单位

2477
01:17:45,533 --> 01:17:46,600
对齐它就行了

2478
01:17:46,600 --> 01:17:46,933
对吧

2479
01:17:46,933 --> 01:17:47,600
内存里面

2480
01:17:47,600 --> 01:17:50,066
那就可能是在那个内存地址

2481
01:17:50,066 --> 01:17:54,633
比如说是 0，1，2，3

2482
01:17:54,633 --> 01:17:57,166
这些任意一个地址上

2483
01:17:57,166 --> 01:17:59,066
它去乘除它

2484
01:17:59,066 --> 01:18:00,666
比如说这个 10

2485
01:18:00,800 --> 01:18:01,833
等于 ABC

2486
01:18:01,833 --> 01:18:03,433
我随便举个例子

2487
01:18:03,433 --> 01:18:04,533
"ABC"

2488
01:18:04,733 --> 01:18:05,266
这样的话

2489
01:18:05,266 --> 01:18:07,266
拿 ABC 就会初始化这个 buff

2490
01:18:07,266 --> 01:18:09,266
这是 C 的这个语法

2491
01:18:09,333 --> 01:18:11,233
然后我比如说放在这

2492
01:18:11,233 --> 01:18:11,966
这个 buffer 呢

2493
01:18:11,966 --> 01:18:14,033
如果指向，是吧

2494
01:18:14,200 --> 01:18:16,533
那就是 A B C 这俩东西呢

2495
01:18:16,533 --> 01:18:19,633
就分别在这三个地址空间里边

2496
01:18:19,633 --> 01:18:21,733
这三个这个地址上

2497
01:18:22,066 --> 01:18:23,633
然后呢我这个时候

2498
01:18:23,633 --> 01:18:27,200
如果我把这个 buffer 强制转换成

2499
01:18:27,200 --> 01:18:28,733
这 buff不是个指针嘛

2500
01:18:28,766 --> 01:18:36,066
我就强制转换成一个 int * i=buff

2501
01:18:38,400 --> 01:18:40,033
这不是从 1 开始了吗

2502
01:18:40,366 --> 01:18:41,333
但是大家都知道

2503
01:18:41,333 --> 01:18:42,066
i 是什么呢

2504
01:18:42,066 --> 01:18:44,600
i 是 32 位的，对吧

2505
01:18:44,600 --> 01:18:46,466
长度 32 位是 4 字节

2506
01:18:46,466 --> 01:18:49,433
通常它应该在 4 字节这个地方对齐

2507
01:18:49,600 --> 01:18:53,466
也就是说这个 i 如果是 0

2508
01:18:53,633 --> 01:18:58,566
或者是这个 4 这个地方打头的

2509
01:18:59,400 --> 01:19:01,400
这个时候它的访问就是正常的

2510
01:19:01,400 --> 01:19:02,100
对齐的

2511
01:19:02,100 --> 01:19:02,833
如果呢

2512
01:19:02,833 --> 01:19:05,866
你这个 buffer 的这个起始位置

2513
01:19:05,866 --> 01:19:07,066
在 1 这个地方

2514
01:19:07,066 --> 01:19:08,333
你这样去访问

2515
01:19:08,333 --> 01:19:11,266
然后 * i=5

2516
01:19:11,366 --> 01:19:12,466
你给它赋值 5

2517
01:19:12,566 --> 01:19:13,366
那这个程序呢

2518
01:19:13,366 --> 01:19:14,433
就会导致什么

2519
01:19:14,433 --> 01:19:16,166
就是 EBUS

2520
01:19:16,166 --> 01:19:17,033
就是 bus error

2521
01:19:18,233 --> 01:19:19,366
你这程序挂了

2522
01:19:19,933 --> 01:19:21,000
那这种东西呢

2523
01:19:21,000 --> 01:19:22,800
实际上还好理解啊

2524
01:19:22,800 --> 01:19:23,800
就前几年呢

2525
01:19:23,800 --> 01:19:26,066
刚好有个小伙子加我微信

2526
01:19:26,066 --> 01:19:27,233
他请教了我一个问题

2527
01:19:27,300 --> 01:19:28,300
说我这点

2528
01:19:28,466 --> 01:19:30,600
我在一个共享内存里边

2529
01:19:30,666 --> 01:19:32,866
然后呢  a 进程和 b 进程

2530
01:19:33,000 --> 01:19:34,166
a 进程往里边写

2531
01:19:34,166 --> 01:19:36,200
b 进程从那个共享内存里面读

2532
01:19:36,833 --> 01:19:38,333
它有的时候就正常

2533
01:19:38,333 --> 01:19:39,800
有的时候就不正常

2534
01:19:40,033 --> 01:19:43,233
后来我看了一下它那数据结构

2535
01:19:43,300 --> 01:19:44,000
那个数据结构

2536
01:19:44,000 --> 01:19:47,000
的确是写的是这个乱七八糟

2537
01:19:47,133 --> 01:19:48,366
我大概率就知道

2538
01:19:48,366 --> 01:19:51,133
它是因为对齐问题导致的

2539
01:19:51,600 --> 01:19:52,700
就是对齐问题导致的

2540
01:19:52,700 --> 01:19:53,633
什么意思呢

2541
01:19:53,733 --> 01:19:56,933
就比如说他分配这个地址吧

2542
01:19:57,400 --> 01:19:58,666
他还用了那个什么，夯实那个地址

2543
01:19:58,733 --> 01:19:59,733
夯实那个地址

2544
01:20:00,500 --> 01:20:01,600
然后这个结构

2545
01:20:02,933 --> 01:20:07,566
然后比如说 int a;  char b;

2546
01:20:07,566 --> 01:20:08,200
然后呢

2547
01:20:08,200 --> 01:20:10,466
马上又来个 short c;

2548
01:20:10,466 --> 01:20:10,966
然后呢

2549
01:20:10,966 --> 01:20:13,033
这个东西呢就是 padding

2550
01:20:13,033 --> 01:20:14,066
就是夯实的

2551
01:20:14,066 --> 01:20:15,833
夯实那个词是啥来着

2552
01:20:15,900 --> 01:20:16,900
你看这个东西呢

2553
01:20:16,900 --> 01:20:18,533
如果是夯实的是吧

2554
01:20:18,533 --> 01:20:20,400
然后正常

2555
01:20:20,966 --> 01:20:22,233
可能

2556
01:20:22,233 --> 01:20:25,533
你在一个单独的进群里面去访问的时候

2557
01:20:25,533 --> 01:20:27,766
它已经做了相应的处理

2558
01:20:27,766 --> 01:20:28,666
相应的处理

2559
01:20:28,666 --> 01:20:29,800
它就不会出错

2560
01:20:29,800 --> 01:20:32,566
但是你把它共享到另外一个进程的时候

2561
01:20:32,766 --> 01:20:33,566
这个进程呢

2562
01:20:33,566 --> 01:20:36,233
它又不知道你这结构是夯实的，是吧

2563
01:20:36,366 --> 01:20:36,800
然后呢

2564
01:20:36,800 --> 01:20:39,066
你就按这个东西呢又给它去访问

2565
01:20:39,166 --> 01:20:42,800
这个时候就跨哧一下就会出现这个总线错误

2566
01:20:42,900 --> 01:20:44,200
就出现总线错误

2567
01:20:44,366 --> 01:20:48,000
这个呢就会就是这种现象

2568
01:20:48,000 --> 01:20:48,900
那总线错误

2569
01:20:48,900 --> 01:20:50,566
通常我们遇到总线错误的时候呢

2570
01:20:50,566 --> 01:20:52,566
一般就是因为对齐导致的

2571
01:20:52,766 --> 01:20:54,533
对，packed 夯实

2572
01:20:54,533 --> 01:20:56,066
packec 指的是啥呢

2573
01:20:56,066 --> 01:20:58,100
就是把这个结构压实了

2574
01:20:58,266 --> 01:21:00,666
中间别给我出现那个空洞

2575
01:21:00,900 --> 01:21:02,400
这个呢尤其要注意

2576
01:21:02,400 --> 01:21:03,800
就是说是对齐

2577
01:21:03,833 --> 01:21:05,400
它会导致一些对齐的问题

2578
01:21:05,733 --> 01:21:06,233
然后呢

2579
01:21:06,233 --> 01:21:07,166
我们再往下看

2580
01:21:07,333 --> 01:21:10,500
那内存出现泄露的情况啊

2581
01:21:10,800 --> 01:21:13,200
如果你分配内存，不停的分配内存

2582
01:21:13,200 --> 01:21:14,666
但是从来不释放内存

2583
01:21:14,666 --> 01:21:17,200
或者是中间就算是有一个地方

2584
01:21:17,200 --> 01:21:18,000
你忘了

2585
01:21:18,066 --> 01:21:20,333
你这个程序在不停的调这个函数的时候

2586
01:21:20,333 --> 01:21:22,933
就有可能会导致你的程序什么呢

2587
01:21:23,066 --> 01:21:24,500
变得越来越慢

2588
01:21:24,500 --> 01:21:25,666
越来越慢啊

2589
01:21:26,000 --> 01:21:27,666
这是一个特别的一个现象

2590
01:21:27,666 --> 01:21:29,800
就是如果你这程序正常跑

2591
01:21:29,800 --> 01:21:30,800
算一个东西

2592
01:21:31,200 --> 01:21:32,600
可能一秒就完了

2593
01:21:32,600 --> 01:21:34,166
结果呢跑的时间长了之后

2594
01:21:34,166 --> 01:21:35,766
就变成 10 秒

2595
01:21:35,766 --> 01:21:37,600
变成这个 100 秒

2596
01:21:37,600 --> 01:21:38,500
还不能那个什么

2597
01:21:38,500 --> 01:21:39,166
那这个时候呢

2598
01:21:39,166 --> 01:21:41,600
通常就是内存出现泄漏了

2599
01:21:42,166 --> 01:21:43,266
然后还有一种现象

2600
01:21:43,266 --> 01:21:44,966
就是栈被破坏的时候

2601
01:21:44,966 --> 01:21:47,133
栈，就是栈帧，对吧

2602
01:21:47,133 --> 01:21:48,300
大家都知道栈帧嘛

2603
01:21:48,300 --> 01:21:50,566
就是一个函数里面你越界访问

2604
01:21:50,566 --> 01:21:51,666
读还没问题

2605
01:21:51,666 --> 01:21:53,400
你又往里写，越界了

2606
01:21:53,400 --> 01:21:54,200
然后这个时候呢

2607
01:21:54,200 --> 01:21:56,533
这个函数呢就会跳飞

2608
01:21:56,533 --> 01:21:57,733
然后你拿 GDB

2609
01:21:57,733 --> 01:22:00,233
这时这时候你去调试的时候就会出现什么呢

2610
01:22:00,533 --> 01:22:03,133
就会出现那个函数的返回

2611
01:22:03,133 --> 01:22:03,933
就是那个栈

2612
01:22:04,133 --> 01:22:05,533
它不是栈的那个

2613
01:22:05,533 --> 01:22:07,666
就函数调用的那个嵌套关系吗

2614
01:22:07,733 --> 01:22:10,200
你就会看见这个前面全是问号

2615
01:22:10,933 --> 01:22:12,833
或者甚至有 0 的位置

2616
01:22:13,233 --> 01:22:13,833
那这个时候呢

2617
01:22:13,833 --> 01:22:16,133
就是大概率你的栈呐

2618
01:22:16,133 --> 01:22:17,133
被破坏了

2619
01:22:17,133 --> 01:22:22,033
这个就是在栈里面有那个 Stack Overflow

2620
01:22:22,133 --> 01:22:24,100
或者 Underflow 这种情况

2621
01:22:24,800 --> 01:22:26,600
然后就这些现象

2622
01:22:26,600 --> 01:22:27,800
实际上很好判断

2623
01:22:27,800 --> 01:22:28,800
经验多了之后

2624
01:22:28,800 --> 01:22:30,533
你就会很容易分辨

2625
01:22:30,533 --> 01:22:32,033
就程序你跑的时候

2626
01:22:32,033 --> 01:22:33,200
跑的什么情况

2627
01:22:33,200 --> 01:22:34,233
你就马上就能知道

2628
01:22:34,233 --> 01:22:36,366
你这个大概率是出现了什么问题

2629
01:22:36,566 --> 01:22:37,633
然后我们接下来看啊

2630
01:22:37,633 --> 01:22:40,266
就是说我们诊断这些内存问题

2631
01:22:40,266 --> 01:22:43,066
那我们在 Linux 底下有很好的工具

2632
01:22:43,266 --> 01:22:44,266
除了 GDB 之外

2633
01:22:44,266 --> 01:22:46,266
这里面我忘了列 GDB

2634
01:22:46,566 --> 01:22:47,733
忘了列那个 GDB

2635
01:22:47,833 --> 01:22:49,366
那 GDB 肯定是很重要的

2636
01:22:49,366 --> 01:22:49,633
对吧

2637
01:22:49,633 --> 01:22:50,733
但是 GDB 呢

2638
01:22:50,733 --> 01:22:51,800
也不是那么好使

2639
01:22:51,800 --> 01:22:52,500
有的时候啊

2640
01:22:52,500 --> 01:22:53,800
诊断这个内存的时候

2641
01:22:53,800 --> 01:22:56,300
那这时候我们就要用一些特别的工具

2642
01:22:56,533 --> 01:22:58,000
那现在用的最多的

2643
01:22:58,000 --> 01:22:59,733
或者是推荐大家使用的工具呢

2644
01:22:59,733 --> 01:23:01,366
就是 valgrind

2645
01:23:01,366 --> 01:23:03,366
这个工具特别好使

2646
01:23:03,900 --> 01:23:05,433
然后呢还有工具是什么呢

2647
01:23:05,533 --> 01:23:05,933
efence

2648
01:23:05,933 --> 01:23:07,833
这个工具目前不用了

2649
01:23:07,833 --> 01:23:09,900
但是我待会儿把它作为一个例子

2650
01:23:09,900 --> 01:23:11,500
因为它很好理解

2651
01:23:11,500 --> 01:23:12,300
给大家讲

2652
01:23:12,333 --> 01:23:13,433
然后呢 asan

2653
01:23:13,433 --> 01:23:14,366
asan 是什么呢

2654
01:23:14,366 --> 01:23:15,800
就一个内存清理器

2655
01:23:15,866 --> 01:23:17,033
asan 这个东西呢

2656
01:23:17,033 --> 01:23:20,266
它是用和编译器配合使用的

2657
01:23:20,933 --> 01:23:22,400
就是你在编译程序的时候

2658
01:23:22,400 --> 01:23:25,233
加一个特定的一个编译选项

2659
01:23:25,333 --> 01:23:28,333
它就会用 asan 的库里面的一些代码

2660
01:23:28,333 --> 01:23:30,466
来替代你的这个分配器

2661
01:23:30,633 --> 01:23:31,800
默认的分配器

2662
01:23:31,800 --> 01:23:32,266
这样的话

2663
01:23:32,266 --> 01:23:34,966
你内存里面有任何的泄露啊什么之类的

2664
01:23:34,966 --> 01:23:37,166
它就很容易发现

2665
01:23:37,400 --> 01:23:38,166
这是 asan

2666
01:23:38,166 --> 01:23:39,066
efence 呢

2667
01:23:39,066 --> 01:23:40,666
它的这个东西呢是什么呢

2668
01:23:40,666 --> 01:23:42,633
你只要在链接程序的时候

2669
01:23:42,633 --> 01:23:45,166
指定 -lefence

2670
01:23:45,166 --> 01:23:45,733
然后呢

2671
01:23:45,733 --> 01:23:48,766
它就用这个库里面实现的 malloc

2672
01:23:48,766 --> 01:23:50,366
或者 calloc 这些函数

2673
01:23:50,366 --> 01:23:53,133
替代你程序里面用到的那些

2674
01:23:53,366 --> 01:23:54,200
然后呢

2675
01:23:54,200 --> 01:23:56,066
它就可以用来发现什么呢

2676
01:23:56,066 --> 01:23:56,900
越界访问

2677
01:23:56,900 --> 01:23:59,333
往下越界或者是往上越界

2678
01:23:59,333 --> 01:24:00,566
它都可以发现

2679
01:24:00,666 --> 01:24:01,666
包括内存泄露

2680
01:24:01,666 --> 01:24:02,866
它也可以发现

2681
01:24:02,966 --> 01:24:04,400
但是 efence 现在用的不多

2682
01:24:04,400 --> 01:24:05,400
是因为它的功能呢

2683
01:24:05,400 --> 01:24:06,366
比较受限

2684
01:24:06,500 --> 01:24:09,066
最后，用的最多的就是 valgrind

2685
01:24:09,066 --> 01:24:10,266
valgrind 是干什么的呢

2686
01:24:10,266 --> 01:24:12,033
我给大家演示一下

2687
01:24:12,033 --> 01:24:15,766
它的这个函数基本的这个用法

2688
01:24:16,800 --> 01:24:18,433
实际上 valgrind 很简单

2689
01:24:20,000 --> 01:24:22,233
我现在调试基本上都用 valgrind 了

2690
01:24:22,233 --> 01:24:22,766
为什么呢

2691
01:24:22,766 --> 01:24:25,300
就是特别简单

2692
01:24:25,500 --> 01:24:28,600
我们就是跑一下我们这个 purc

2693
01:24:28,600 --> 01:24:29,933
-c thread

2694
01:24:29,933 --> 01:24:31,200
然后是

2695
01:24:32,166 --> 01:24:34,366
比如说是 hvml/hello.hvml

2696
01:24:39,200 --> 01:24:40,400
大家看一下

2697
01:24:40,400 --> 01:24:41,433
它就执行完了

2698
01:24:41,433 --> 01:24:42,066
这个程序呢

2699
01:24:42,066 --> 01:24:42,833
正常啊

2700
01:24:42,833 --> 01:24:45,366
如果我不加 valgrind 这个东西的话

2701
01:24:46,000 --> 01:24:48,666
它的这个输出就是打一个 hello world

2702
01:24:48,700 --> 01:24:49,933
然后就退出了

2703
01:24:50,233 --> 01:24:51,066
hello world

2704
01:24:51,100 --> 01:24:53,433
然后如果我加了 valgrind 的时候呢

2705
01:24:53,433 --> 01:24:54,900
它先会启 valgrind

2706
01:24:54,900 --> 01:24:57,100
然后 valgrind 再去跑这个程序

2707
01:24:57,400 --> 01:24:58,566
所以它会有什么

2708
01:24:58,566 --> 01:24:59,433
Memcheck

2709
01:24:59,633 --> 01:25:03,166
它是一个内存的错误检测器

2710
01:25:03,166 --> 01:25:04,400
内存错误检测器

2711
01:25:04,433 --> 01:25:07,033
那这是我的程序运行的时候的输出

2712
01:25:07,066 --> 01:25:08,833
然后最后退出的时候

2713
01:25:08,833 --> 01:25:10,500
它会给你一个什么呢

2714
01:25:10,500 --> 01:25:13,400
一个 HEAP SUMMARY

2715
01:25:13,400 --> 01:25:14,233
这个表示什么呢

2716
01:25:14,233 --> 01:25:16,000
就是你的堆的使用情况

2717
01:25:16,566 --> 01:25:18,633
它说 in use a ekit

2718
01:25:18,633 --> 01:25:19,266
表示什么呢

2719
01:25:19,266 --> 01:25:21,766
就是你退出的时候还有这么多块在用

2720
01:25:22,300 --> 01:25:23,866
啊还有这么多块在用

2721
01:25:23,866 --> 01:25:26,766
但这个并不意味着它程序有内存泄露

2722
01:25:26,766 --> 01:25:27,866
因为有些东西呢

2723
01:25:27,866 --> 01:25:30,233
是 c 库它自己分配的

2724
01:25:30,233 --> 01:25:31,100
它没有释放

2725
01:25:31,100 --> 01:25:31,833
或者是什么样子

2726
01:25:31,833 --> 01:25:33,666
反正是那个不用管

2727
01:25:33,866 --> 01:25:35,500
那真正的 LEAK SUMMARY

2728
01:25:35,500 --> 01:25:36,966
才是我们真正要关心的

2729
01:25:36,966 --> 01:25:39,400
其中有一个 definitely lost

2730
01:25:39,400 --> 01:25:39,800
实际上是什么

2731
01:25:39,966 --> 01:25:42,300
就确定性的丢掉了

2732
01:25:42,666 --> 01:25:44,700
当然我们的程序呢目前没有

2733
01:25:44,833 --> 01:25:46,866
0 bytes 0 block

2734
01:25:47,233 --> 01:25:50,566
然后 indirectly 就是间接的丢掉的

2735
01:25:50,700 --> 01:25:51,366
还有一个呢

2736
01:25:51,366 --> 01:25:51,966
就是报告呢

2737
01:25:51,966 --> 01:25:53,633
叫做 possibly lost

2738
01:25:53,633 --> 01:25:55,166
就是可能性丢失的

2739
01:25:55,166 --> 01:25:56,133
因为这种可能性呢

2740
01:25:56,133 --> 01:25:57,366
它有的时候呢

2741
01:25:57,366 --> 01:25:59,933
它不能就是准确的判断

2742
01:26:00,666 --> 01:26:01,500
那我们这个时候呢

2743
01:26:01,500 --> 01:26:06,700
它会有个提示说你加上 --leak-check=full

2744
01:26:06,700 --> 01:26:11,233
你就可以看到这个它的所有的这个详细信息

2745
01:26:13,833 --> 01:26:17,233
我们加上这个选项再跑

2746
01:26:17,233 --> 01:26:17,866
这个时候呢

2747
01:26:17,866 --> 01:26:19,166
它就会给你什么呢

2748
01:26:19,166 --> 01:26:22,700
给你一个 HEAP SUMMARY

2749
01:26:22,700 --> 01:26:26,133
它不是说有80字节可能丢失吗

2750
01:26:26,233 --> 01:26:27,833
它在哪丢掉了呢

2751
01:26:27,833 --> 01:26:29,500
就在这个地方

2752
01:26:33,700 --> 01:26:34,866
这个 purc init

2753
01:26:34,866 --> 01:26:36,733
init modules 的时候

2754
01:26:37,066 --> 01:26:37,833
这个东西呢

2755
01:26:37,833 --> 01:26:39,366
你就会看到什么呢

2756
01:26:39,933 --> 01:26:41,033
它就会给你

2757
01:26:41,233 --> 01:26:44,166
告诉你是什么地方分配的内存

2758
01:26:44,666 --> 01:26:45,266
这个内存呢

2759
01:26:45,266 --> 01:26:47,066
当然最终是 malloc 分配的

2760
01:26:47,066 --> 01:26:48,433
然后在哪调的呢

2761
01:26:48,633 --> 01:26:50,233
是在这个

2762
01:26:50,233 --> 01:26:51,666
然后再往下看

2763
01:26:51,666 --> 01:26:54,033
它是在一个哈西表里边

2764
01:26:54,033 --> 01:26:56,533
然后呢在创建一个线程的时候

2765
01:26:56,733 --> 01:26:59,866
然后发现的

2766
01:27:00,233 --> 01:27:02,300
然后我们有这些东西之后

2767
01:27:02,300 --> 01:27:03,866
你就很容易去定位它

2768
01:27:03,866 --> 01:27:05,100
你比如说在这，是吧

2769
01:27:05,100 --> 01:27:06,233
这不是栈的那个

2770
01:27:06,366 --> 01:27:07,433
调用栈吗

2771
01:27:07,533 --> 01:27:10,000
runloop init main 你在这里面去看

2772
01:27:10,000 --> 01:27:12,533
runloop.cpp:254

2773
01:27:12,933 --> 01:27:14,833
然后呢你看它这里边实际上呢

2774
01:27:14,833 --> 01:27:16,266
是被哪个函数调用了

2775
01:27:16,266 --> 01:27:17,633
是 pthread once slow

2776
01:27:17,666 --> 01:27:19,433
也就是说实际上这个代码呢

2777
01:27:19,433 --> 01:27:21,766
它是调用了一个 pthread 的

2778
01:27:21,766 --> 01:27:23,900
这么一个一次性的这么一个东西的

2779
01:27:23,900 --> 01:27:25,666
一个初始化的一个东西

2780
01:27:25,700 --> 01:27:27,500
然后在那里边分配了一个内存

2781
01:27:27,500 --> 01:27:28,133
这个内存呢

2782
01:27:28,133 --> 01:27:29,900
被判定为可能丢失

2783
01:27:30,200 --> 01:27:31,166
它不能确定

2784
01:27:31,166 --> 01:27:32,033
因为有些东西呢

2785
01:27:32,033 --> 01:27:32,800
不是说

2786
01:27:33,066 --> 01:27:34,033
就像 once

2787
01:27:34,033 --> 01:27:34,666
这个东西呢

2788
01:27:34,666 --> 01:27:35,333
指的是什么

2789
01:27:35,333 --> 01:27:36,433
一个 pthread 里面

2790
01:27:36,433 --> 01:27:38,533
只会初始化一次的那么一个东西

2791
01:27:38,533 --> 01:27:39,100
那个东西呢

2792
01:27:39,100 --> 01:27:40,700
它的确是有用

2793
01:27:40,700 --> 01:27:42,033
但只会用一次

2794
01:27:42,033 --> 01:27:42,766
而且呢

2795
01:27:42,766 --> 01:27:43,600
你不释放它

2796
01:27:43,600 --> 01:27:45,400
实际上也不会造成什么后果

2797
01:27:45,400 --> 01:27:46,133
所以呢

2798
01:27:46,133 --> 01:27:48,366
它这里面就给你报告了一个什么呢

2799
01:27:48,366 --> 01:27:52,600
就是报告了一个 possibly lost

2800
01:27:52,600 --> 01:27:53,400
possibly lost

2801
01:27:53,566 --> 01:27:55,566
那更多的这个例子

2802
01:27:55,566 --> 01:27:57,100
大家可以去看一看

2803
01:27:57,100 --> 01:27:59,033
看一看这个东西的这个用法

2804
01:27:59,233 --> 01:28:00,200
特别好用

2805
01:28:00,366 --> 01:28:03,300
接下来马上就有人提出反对

2806
01:28:03,300 --> 01:28:04,900
valgrind 太影响性能

2807
01:28:05,200 --> 01:28:05,866
我告诉你

2808
01:28:05,866 --> 01:28:08,366
所有的这个内存检测工具

2809
01:28:08,433 --> 01:28:09,966
都会影响性能

2810
01:28:09,966 --> 01:28:11,366
都会影响性能

2811
01:28:11,433 --> 01:28:13,233
那好的办法是什么

2812
01:28:13,233 --> 01:28:14,700
好的办法是

2813
01:28:14,800 --> 01:28:17,400
在单元测试的时候用 valgrind

2814
01:28:17,400 --> 01:28:19,966
而不是你跑一个完整程序的时候用 valgrind

2815
01:28:19,966 --> 01:28:21,100
我给大家举个例子啊

2816
01:28:21,100 --> 01:28:24,400
就 WebKit 这种大的浏览器

2817
01:28:25,000 --> 01:28:27,700
这个浏览器你用 valgrind 去跑

2818
01:28:28,400 --> 01:28:30,966
那可能装载就得装载十分钟

2819
01:28:31,466 --> 01:28:33,833
还得看你的这个硬件性能和内存

2820
01:28:34,033 --> 01:28:35,333
有可能还会失败

2821
01:28:35,533 --> 01:28:36,033
所以的话

2822
01:28:36,033 --> 01:28:38,033
valgrind 它在哪个地方去用啊

2823
01:28:38,133 --> 01:28:39,866
就在单元测试里面去用

2824
01:28:40,466 --> 01:28:42,533
你像我们这个 PurC 这个项目里面

2825
01:28:42,800 --> 01:28:43,666
那单元测试

2826
01:28:43,666 --> 01:28:45,733
大概有 100 多个单元测试程序

2827
01:28:45,733 --> 01:28:47,333
我们就可以开启

2828
01:28:47,366 --> 01:28:50,566
开启 valgrind 去每一个单元测试去跑

2829
01:28:50,600 --> 01:28:54,166
这样确保每一个单元测试结果是什么呢

2830
01:28:54,166 --> 01:28:55,566
都是没有内存泄露的

2831
01:28:55,566 --> 01:28:59,100
然后你再去跑一些这个完整的测试用例

2832
01:28:59,100 --> 01:29:01,400
那就可以大概率保证

2833
01:29:01,400 --> 01:29:03,166
你的这个程序内存泄露

2834
01:29:03,166 --> 01:29:04,533
或者是什么各种各样的

2835
01:29:04,533 --> 01:29:06,266
这个内存的这个使用错误

2836
01:29:06,266 --> 01:29:07,033
都没有

2837
01:29:07,033 --> 01:29:07,833
都没有

2838
01:29:08,433 --> 01:29:09,766
这就是 valgrind

2839
01:29:09,766 --> 01:29:12,733
因为我们还会专门讲这个调试

2840
01:29:12,733 --> 01:29:14,266
就是 valgrind 这些工具

2841
01:29:14,266 --> 01:29:17,200
所以我今天呢就不深入进去了

2842
01:29:17,533 --> 01:29:19,400
我们接下来稍微轻松一点

2843
01:29:19,400 --> 01:29:20,433
我现在问一下

2844
01:29:20,433 --> 01:29:22,200
就是内存检测工具

2845
01:29:22,200 --> 01:29:25,766
你们觉得它大概率是什么样的一个实现原理

2846
01:29:25,766 --> 01:29:26,800
就比如说举例子

2847
01:29:26,800 --> 01:29:28,800
如何诊断内存的越界访问

2848
01:29:29,033 --> 01:29:30,233
向上或者向下

2849
01:29:30,466 --> 01:29:32,333
就比如说一块内存，是吧

2850
01:29:32,533 --> 01:29:36,533
我们知道那个 Rust 语言有越界访问的

2851
01:29:36,533 --> 01:29:38,466
一个数组它用越界访问

2852
01:29:38,466 --> 01:29:41,733
那是它编译器给你提供的支持

2853
01:29:41,866 --> 01:29:43,466
就比如说这块内存，是吧

2854
01:29:43,933 --> 01:29:47,233
就 3 个字节 0 1 2

2855
01:29:47,233 --> 01:29:48,033
然后呢

2856
01:29:48,066 --> 01:29:51,966
我往前访问和往后访问这个东西

2857
01:29:51,966 --> 01:29:53,000
它怎么检测呢

2858
01:29:53,266 --> 01:29:54,066
因为我们知道啊

2859
01:29:54,066 --> 01:29:56,100
如果是从堆里面分配的

2860
01:29:56,100 --> 01:29:57,633
比如说我们从堆里面分配

2861
01:29:57,700 --> 01:29:59,133
那刚好这个东西呢

2862
01:29:59,133 --> 01:30:03,033
它就是 0 1 2 放在这中间

2863
01:30:03,433 --> 01:30:05,733
实际上你在这里边写

2864
01:30:06,133 --> 01:30:08,566
和读这里边的东西

2865
01:30:08,566 --> 01:30:11,966
或者是写往前就是越界访问

2866
01:30:11,966 --> 01:30:12,933
写还是读

2867
01:30:13,066 --> 01:30:16,233
实际上它不会造成 segment fault 这种东西

2868
01:30:16,466 --> 01:30:19,233
它只会在后面才会显示它的副作用

2869
01:30:19,700 --> 01:30:20,266
对吧

2870
01:30:20,266 --> 01:30:21,133
那好啊

2871
01:30:21,133 --> 01:30:22,866
这个东西的前或后

2872
01:30:22,866 --> 01:30:23,766
它怎么去判断

2873
01:30:23,966 --> 01:30:25,300
这内存检测工具

2874
01:30:25,300 --> 01:30:28,333
它如何去判断/诊断这个内存的越界访问呢

2875
01:30:28,500 --> 01:30:29,666
如果是在一个堆里面

2876
01:30:29,666 --> 01:30:32,066
它根本不会立即导致问题

2877
01:30:32,500 --> 01:30:33,300
对吧

2878
01:30:33,300 --> 01:30:35,133
黄威的这个说法

2879
01:30:35,133 --> 01:30:38,333
分配的内存头尾留 poison data

2880
01:30:38,333 --> 01:30:40,233
这个指的就是毒药数据嘛

2881
01:30:41,133 --> 01:30:42,400
但是这个毒药数据呢

2882
01:30:42,400 --> 01:30:43,233
你怎么留

2883
01:30:43,866 --> 01:30:46,333
或者是你留毒药数据呢

2884
01:30:46,333 --> 01:30:48,200
你只能说我判断

2885
01:30:48,200 --> 01:30:49,400
这个东西被改了

2886
01:30:49,400 --> 01:30:50,833
原来我初始化成 0 了

2887
01:30:50,833 --> 01:30:51,833
然后呢或者是

2888
01:30:51,833 --> 01:30:53,633
或者是另外一个数据是吧

2889
01:30:53,633 --> 01:30:54,433
你给它

2890
01:30:55,000 --> 01:30:57,466
那那如果你毒药数据就是 0

2891
01:30:57,466 --> 01:30:58,466
你设置的是 0

2892
01:30:58,466 --> 01:30:59,400
然后我写进去 0

2893
01:30:59,400 --> 01:31:00,600
你也判断不出来啊

2894
01:31:01,733 --> 01:31:02,066
对吧

2895
01:31:02,066 --> 01:31:03,466
所以毒药数据这个

2896
01:31:03,466 --> 01:31:05,100
这个方案也不太合理

2897
01:31:05,666 --> 01:31:07,333
也是没办法去做到的

2898
01:31:08,400 --> 01:31:10,800
影子内存

2899
01:31:10,800 --> 01:31:11,866
影子内存呢

2900
01:31:11,866 --> 01:31:14,900
这个是就是 valgrind 实现的

2901
01:31:14,900 --> 01:31:17,400
对，影子内存是v valgrind 的方案

2902
01:31:17,566 --> 01:31:18,600
也就是说实质上呢

2903
01:31:18,600 --> 01:31:20,866
valgrind 它把所有的这个

2904
01:31:20,866 --> 01:31:22,966
就是这种内存访问

2905
01:31:22,966 --> 01:31:24,600
全都给你记录在案了

2906
01:31:24,600 --> 01:31:26,366
你看它打印出来那个信息

2907
01:31:26,366 --> 01:31:28,233
为什么它会导致程序变慢

2908
01:31:28,233 --> 01:31:30,733
就是因为它就是给你一个影子内存

2909
01:31:30,733 --> 01:31:31,566
让你在那做

2910
01:31:31,566 --> 01:31:32,166
做完了之后

2911
01:31:32,166 --> 01:31:33,200
我把所有的这些东西

2912
01:31:33,200 --> 01:31:34,466
全都给你记录下来

2913
01:31:34,466 --> 01:31:34,833
对吧啊

2914
01:31:35,033 --> 01:31:36,166
函数的调用栈

2915
01:31:36,233 --> 01:31:37,833
你是读了还是写了

2916
01:31:37,833 --> 01:31:39,500
全都给你记录下来

2917
01:31:40,033 --> 01:31:40,766
我们现在啊

2918
01:31:40,766 --> 01:31:43,666
就是给大家介绍一个比较简单的方法

2919
01:31:43,900 --> 01:31:47,566
这个简单的方法刚好就是 efence 用的

2920
01:31:48,700 --> 01:31:49,500
什么意思呢

2921
01:31:49,666 --> 01:31:52,433
对，asan 也是影子内存方法

2922
01:31:52,500 --> 01:31:54,733
那我给大家举一个很简单的东西

2923
01:31:54,733 --> 01:31:56,266
我现在就是要

2924
01:31:56,266 --> 01:31:57,033
要什么呢

2925
01:31:57,033 --> 01:31:57,733
判断

2926
01:31:57,733 --> 01:31:59,966
就是这样的一个 3 个字节的东西

2927
01:32:00,633 --> 01:32:01,333
判断什么呢

2928
01:32:01,333 --> 01:32:03,633
判断它是不是往前越界

2929
01:32:04,166 --> 01:32:05,033
往前越界

2930
01:32:05,233 --> 01:32:06,566
那实际上很简单

2931
01:32:07,700 --> 01:32:08,800
什么意思呢

2932
01:32:08,800 --> 01:32:10,833
我不管分配多大的内存

2933
01:32:10,833 --> 01:32:12,233
我全给它 4K

2934
01:32:13,400 --> 01:32:13,766
对吧

2935
01:32:13,766 --> 01:32:15,100
我就全给它 4K

2936
01:32:16,133 --> 01:32:17,233
通过 mmap

2937
01:32:17,833 --> 01:32:21,366
我就给它分配 4K 的这个大小，对吧

2938
01:32:21,633 --> 01:32:24,800
然后你一旦往这儿去访问

2939
01:32:25,333 --> 01:32:27,166
程序就 segment fault

2940
01:32:27,533 --> 01:32:28,333
明白了吧

2941
01:32:28,766 --> 01:32:31,300
但是你往后反问它管不着

2942
01:32:31,300 --> 01:32:32,866
除非是你超到这

2943
01:32:33,266 --> 01:32:36,766
那为了判断这个东西呢

2944
01:32:36,766 --> 01:32:39,200
是往后越界的这种情况呢

2945
01:32:39,200 --> 01:32:40,833
我就是用这个方法

2946
01:32:43,000 --> 01:32:45,566
我不是每次分配的时候以 4K 为单位吗

2947
01:32:45,566 --> 01:32:48,000
但是我给你的地址是这

2948
01:32:48,000 --> 01:32:49,233
返回的地址

2949
01:32:49,633 --> 01:32:51,533
就返回的这个地址

2950
01:32:51,533 --> 01:32:53,600
分配的返回地址是在这

2951
01:32:55,866 --> 01:32:57,900
然后呢你往后访问

2952
01:33:00,100 --> 01:33:01,266
那是不是 segment fault

2953
01:33:01,866 --> 01:33:02,033
对吧

2954
01:33:02,266 --> 01:33:03,233
就会 segment fault

2955
01:33:03,233 --> 01:33:04,500
因为这个页嘛

2956
01:33:04,500 --> 01:33:07,033
往往是一个页一个页单独的

2957
01:33:07,033 --> 01:33:08,066
一个一个的页

2958
01:33:08,300 --> 01:33:09,866
而且通过 mmap 之后呢

2959
01:33:09,866 --> 01:33:11,100
这些地址

2960
01:33:11,100 --> 01:33:12,800
基本上也都是不相连的

2961
01:33:12,800 --> 01:33:13,033
所以

2962
01:33:13,033 --> 01:33:15,500
它就可以通过这样的一个简单的方法

2963
01:33:15,566 --> 01:33:18,133
就可以把这个 underflow

2964
01:33:18,133 --> 01:33:19,800
或者是那个 overflow

2965
01:33:19,800 --> 01:33:20,700
这是 overflow

2966
01:33:20,700 --> 01:33:21,700
这是 underflow

2967
01:33:21,700 --> 01:33:23,833
都给它及时的检测出来

2968
01:33:23,833 --> 01:33:25,233
那 efence 的做法是什么

2969
01:33:25,233 --> 01:33:26,133
出现这种情况

2970
01:33:26,133 --> 01:33:28,633
你用 GDB 它马上就在那个地方出错

2971
01:33:28,633 --> 01:33:31,033
你马上就知道这个地方越界了

2972
01:33:31,033 --> 01:33:33,100
这就是 efence 的这个用法

2973
01:33:33,466 --> 01:33:34,866
那 efence 的做法的话呢

2974
01:33:34,866 --> 01:33:37,200
如果你要检测 overflow 或 underflow

2975
01:33:37,200 --> 01:33:39,233
它分别通过环境变量来控制

2976
01:33:39,633 --> 01:33:40,300
这也是为什么

2977
01:33:40,300 --> 01:33:41,900
它通过环境变量来控制这个

2978
01:33:41,900 --> 01:33:45,400
它一次只能判断是 overflow

2979
01:33:45,400 --> 01:33:46,200
还是 underflow

2980
01:33:46,200 --> 01:33:48,500
就是因为它的实现方式是这样的

2981
01:33:48,500 --> 01:33:49,633
就是通过 mmap

2982
01:33:49,700 --> 01:33:52,933
每次都给你返回一个页为单位的一个内存

2983
01:33:53,233 --> 01:33:54,833
所以呢这个 efence 呢

2984
01:33:54,866 --> 01:33:55,866
也是为什么后来

2985
01:33:55,866 --> 01:33:57,800
因为比较简单嘛

2986
01:33:58,066 --> 01:33:59,500
能做的事呢有限

2987
01:33:59,733 --> 01:34:00,366
所以呢

2988
01:34:00,366 --> 01:34:02,966
后来就慢慢的被其它的工具替代了

2989
01:34:03,133 --> 01:34:05,433
像 asan 或者是那个什么

2990
01:34:05,633 --> 01:34:08,033
那如何诊断释放后仍然使用呢

2991
01:34:08,033 --> 01:34:08,833
也一样

2992
01:34:09,066 --> 01:34:10,900
就是我刚才说的这个方法

2993
01:34:11,066 --> 01:34:12,666
就是你每次分配的内存呢

2994
01:34:12,666 --> 01:34:14,633
全都是通过 mmap 返回的

2995
01:34:14,633 --> 01:34:16,500
而且是以 page 为单位返回的

2996
01:34:16,600 --> 01:34:19,100
那你释放那就是 unmap

2997
01:34:19,166 --> 01:34:21,033
unmap 的这个虚拟地址就无效了

2998
01:34:21,033 --> 01:34:22,933
那你如果再继续使用

2999
01:34:22,933 --> 01:34:25,133
马上就会出现 segment fault

3000
01:34:25,233 --> 01:34:26,433
这时候配合 GDB

3001
01:34:26,433 --> 01:34:27,866
你就立即就能诊断出来

3002
01:34:27,866 --> 01:34:30,366
这个代码的哪个地方出现问题

3003
01:34:30,466 --> 01:34:32,033
好，接着往下

3004
01:34:32,033 --> 01:34:33,233
常见内存使用问题

3005
01:34:33,533 --> 01:34:36,300
这个就是到了大家比较感兴趣那个

3006
01:34:36,300 --> 01:34:37,600
叫做碎片化

3007
01:34:37,600 --> 01:34:38,566
碎片化的那个地方

3008
01:34:38,666 --> 01:34:39,466
就这个呢

3009
01:34:39,466 --> 01:34:43,033
就是涉及到我们堆的这个实现方式

3010
01:34:43,100 --> 01:34:44,800
那出现碎片化实际上呢

3011
01:34:44,800 --> 01:34:46,133
也是一个比较正常的

3012
01:34:46,133 --> 01:34:47,133
因为我们堆呢

3013
01:34:47,166 --> 01:34:48,833
通常是要什么呢

3014
01:34:49,266 --> 01:34:53,600
就是支持变长大小的

3015
01:34:53,900 --> 01:34:55,500
那支持变长大小的话呢

3016
01:34:55,500 --> 01:34:59,400
比如说我刚开始分配了这么长的一块内存

3017
01:34:59,400 --> 01:35:00,233
这块内存

3018
01:35:00,766 --> 01:35:01,100
然后呢

3019
01:35:01,100 --> 01:35:03,566
我又分配了这么小的一块内存

3020
01:35:03,600 --> 01:35:05,000
然后呢，哎

3021
01:35:05,000 --> 01:35:06,500
小的内存就拼命分配

3022
01:35:06,500 --> 01:35:08,800
然后你突然又分配了一块特别大的内存

3023
01:35:08,800 --> 01:35:09,700
把剩下的东西呢

3024
01:35:09,700 --> 01:35:10,800
全都占掉了

3025
01:35:10,966 --> 01:35:13,100
然后呢你给我分配一些小的内存

3026
01:35:13,200 --> 01:35:14,833
那小的内存通常来讲的话呢

3027
01:35:14,833 --> 01:35:15,800
都是可以的

3028
01:35:15,866 --> 01:35:17,033
可以分配到的

3029
01:35:17,300 --> 01:35:19,066
然后你看这个时候呢

3030
01:35:19,200 --> 01:35:21,066
你又把一些东西给释放掉

3031
01:35:21,233 --> 01:35:21,833
哎比如说你

3032
01:35:21,833 --> 01:35:25,233
这你又释放掉了一些东西是吧

3033
01:35:25,666 --> 01:35:26,466
好

3034
01:35:26,866 --> 01:35:29,233
现在假设我要分配

3035
01:35:30,433 --> 01:35:32,100
就是这么大的一块内存

3036
01:35:34,666 --> 01:35:36,233
那你就会发现什么呢

3037
01:35:36,533 --> 01:35:37,633
这放不下

3038
01:35:37,866 --> 01:35:39,066
这也放不下

3039
01:35:39,066 --> 01:35:43,200
但实际上这两块空的加起来满足

3040
01:35:43,600 --> 01:35:44,633
这就叫碎片化

3041
01:35:44,800 --> 01:35:46,833
也就是说碎片化会导致什么呢

3042
01:35:46,833 --> 01:35:48,900
本来有足够的这个空间

3043
01:35:49,066 --> 01:35:51,333
但是你就是分配不到

3044
01:35:52,033 --> 01:35:55,466
那在我们 Linux 底下这种情况怎么办呢

3045
01:35:56,433 --> 01:35:59,466
往上增堆，brk

3046
01:36:00,800 --> 01:36:02,233
往上增长堆

3047
01:36:02,233 --> 01:36:04,700
再增长一个 4K 不就能分配到了吗

3048
01:36:04,866 --> 01:36:06,000
所以在l Linux 底下

3049
01:36:06,000 --> 01:36:07,100
它解决起来很简单

3050
01:36:07,100 --> 01:36:08,100
就是堆

3051
01:36:08,100 --> 01:36:10,433
往上不停的涨长就可以了

3052
01:36:10,433 --> 01:36:11,466
长就可以了

3053
01:36:11,666 --> 01:36:13,833
但是这个在嵌入式系统

3054
01:36:13,833 --> 01:36:15,600
或者是实时操作系统里面

3055
01:36:15,766 --> 01:36:17,366
堆是固定的这种情况之下

3056
01:36:17,366 --> 01:36:18,833
这个就要害了

3057
01:36:18,833 --> 01:36:20,466
这个就麻烦了

3058
01:36:20,466 --> 01:36:22,600
你明明有足够的这个空间

3059
01:36:22,700 --> 01:36:25,300
但是呢你就是分配不到

3060
01:36:25,300 --> 01:36:26,833
这就是所谓的碎片化

3061
01:36:26,866 --> 01:36:28,433
但是碎片化这个东西

3062
01:36:28,666 --> 01:36:30,000
一直有人想解决

3063
01:36:30,000 --> 01:36:31,800
但实际上解决不好

3064
01:36:31,800 --> 01:36:32,400
为什么

3065
01:36:32,533 --> 01:36:33,733
它的代价比较大

3066
01:36:33,833 --> 01:36:35,566
第一我们先看啊

3067
01:36:35,566 --> 01:36:38,766
假设我们要支持碎片化的整理，什么意思呢

3068
01:36:38,766 --> 01:36:39,166
就比如说

3069
01:36:39,166 --> 01:36:39,966
举个例子啊

3070
01:36:40,366 --> 01:36:42,600
你看这明明有吗

3071
01:36:42,600 --> 01:36:44,600
有，那我就可以整理一下嘛

3072
01:36:44,600 --> 01:36:44,900
对吧

3073
01:36:44,900 --> 01:36:45,533
整理一下

3074
01:36:45,533 --> 01:36:45,933
然后呢

3075
01:36:45,933 --> 01:36:47,533
把这块的内存

3076
01:36:47,533 --> 01:36:49,466
这，对吧，搬到那

3077
01:36:49,466 --> 01:36:52,600
然后把这块往这搬，是吧

3078
01:36:52,766 --> 01:36:54,133
整个搬完了之后呢

3079
01:36:54,133 --> 01:36:55,733
大概是这个样子的啊

3080
01:36:55,733 --> 01:36:56,500
搬完了之后呢

3081
01:36:56,500 --> 01:36:58,333
大概是这样哎

3082
01:36:58,333 --> 01:36:59,133
这个东西呢

3083
01:36:59,133 --> 01:37:00,366
就是大概是这样

3084
01:37:00,900 --> 01:37:01,700
嗯

3085
01:37:01,766 --> 01:37:03,166
就这块被分配了

3086
01:37:03,166 --> 01:37:04,666
然后呢这

3087
01:37:04,966 --> 01:37:06,266
就往前错一下

3088
01:37:06,266 --> 01:37:08,066
整个把这东西往前错一下

3089
01:37:08,566 --> 01:37:09,300
错完了之后呢

3090
01:37:09,300 --> 01:37:10,100
你看

3091
01:37:10,533 --> 01:37:12,666
这块内存加上这块内存就足够大了

3092
01:37:12,666 --> 01:37:14,300
然后呢我就可以分配它

3093
01:37:14,300 --> 01:37:14,666
对吧

3094
01:37:14,666 --> 01:37:18,000
这就是内存碎片化整理的基本的原理

3095
01:37:18,200 --> 01:37:21,766
但是这个东西的代价实在是太大了

3096
01:37:22,066 --> 01:37:22,766
为什么对吧

3097
01:37:22,833 --> 01:37:24,600
你看你这样一个 move

3098
01:37:24,666 --> 01:37:26,633
把内存从这里这拷贝

3099
01:37:26,733 --> 01:37:27,166
这本身

3100
01:37:27,166 --> 01:37:30,066
就是一个很耗 CPU 处理的一个过程

3101
01:37:30,433 --> 01:37:30,766
对吧

3102
01:37:31,166 --> 01:37:33,633
然后它带来的另外一个麻烦是什么呢

3103
01:37:34,966 --> 01:37:37,566
我明明分配的这个地方，是吧

3104
01:37:37,566 --> 01:37:39,266
原来是分配在这的

3105
01:37:40,366 --> 01:37:41,633
我在一个变量里面

3106
01:37:41,633 --> 01:37:43,433
把它的这个地址记下来了

3107
01:37:43,766 --> 01:37:46,233
然后呢你那串碎片整理完了之后呢

3108
01:37:46,233 --> 01:37:46,866
这个地址呢

3109
01:37:46,866 --> 01:37:47,800
跑到这了

3110
01:37:48,300 --> 01:37:50,433
我怎么知道你把它放到哪了

3111
01:37:50,866 --> 01:37:51,833
给我改了呢

3112
01:37:51,833 --> 01:37:52,433
对不对

3113
01:37:52,433 --> 01:37:53,500
那这时候怎么办

3114
01:37:53,600 --> 01:37:54,866
那你很麻烦

3115
01:37:54,866 --> 01:37:56,100
对，地址变了

3116
01:37:56,100 --> 01:37:57,166
地址变了

3117
01:37:57,166 --> 01:37:58,200
那怎么办呢

3118
01:37:58,666 --> 01:38:02,233
你就不得不用另外一个东西来索引它

3119
01:38:02,366 --> 01:38:03,166
什么意思啊

3120
01:38:03,433 --> 01:38:04,766
就相当于是什么呢

3121
01:38:04,766 --> 01:38:06,433
你就得用一个

3122
01:38:06,633 --> 01:38:07,566
句柄

3123
01:38:08,633 --> 01:38:09,566
就比如说句柄

3124
01:38:09,566 --> 01:38:11,200
或者是描述符之类的一个东西

3125
01:38:11,200 --> 01:38:13,633
来代表已经分配的一个内存

3126
01:38:13,866 --> 01:38:17,433
然后一个 handle来分配

3127
01:38:17,433 --> 01:38:18,466
这个时候呢

3128
01:38:18,466 --> 01:38:19,333
malloc 呢

3129
01:38:19,333 --> 01:38:21,133
它就变成分配一个

3130
01:38:21,133 --> 01:38:22,800
比如说是 8

3131
01:38:22,800 --> 01:38:24,000
handle 等于这个

3132
01:38:24,300 --> 01:38:24,866
然后呢

3133
01:38:24,866 --> 01:38:27,500
我再要访问真正的这个地址的时候

3134
01:38:27,700 --> 01:38:28,833
我在什么呢

3135
01:38:29,200 --> 01:38:33,100
addr_from handle

3136
01:38:34,333 --> 01:38:35,100
这个时候呢

3137
01:38:35,100 --> 01:38:38,000
我才能真正得到这个 void* p

3138
01:38:38,000 --> 01:38:40,600
然后呢这个 handle

3139
01:38:41,100 --> 01:38:41,700
什么意思啊

3140
01:38:41,700 --> 01:38:43,933
你必须得增加一个这样的函数

3141
01:38:44,766 --> 01:38:45,833
我分配得到的呢

3142
01:38:45,833 --> 01:38:47,300
不是这个直接的地址

3143
01:38:47,300 --> 01:38:48,300
而是一个句柄

3144
01:38:48,366 --> 01:38:49,766
然后我要访问它的时候

3145
01:38:49,766 --> 01:38:50,800
你 from handle

3146
01:38:50,800 --> 01:38:51,833
然后呢这个东西呢

3147
01:38:51,833 --> 01:38:53,000
才能返回一个 p

3148
01:38:53,000 --> 01:38:54,600
然后你再去访问，是吧

3149
01:38:54,733 --> 01:38:56,033
这就麻烦得很嘛

3150
01:38:56,166 --> 01:38:56,766
是不是

3151
01:38:56,766 --> 01:38:58,400
而且还有一个问题

3152
01:38:58,633 --> 01:38:59,366
还有个问题是什么呢

3153
01:38:59,366 --> 01:39:01,133
你必须保存一个表

3154
01:39:02,300 --> 01:39:03,233
这个 handle

3155
01:39:05,633 --> 01:39:10,366
到这个 pointer 的一个表

3156
01:39:10,566 --> 01:39:11,500
一个 table

3157
01:39:14,400 --> 01:39:15,366
这个 table

3158
01:39:15,366 --> 01:39:17,600
而且还是要变长的，是吧

3159
01:39:17,700 --> 01:39:19,966
虽然每一个项都是固定的

3160
01:39:20,000 --> 01:39:20,500
但是呢你想啊

3161
01:39:20,533 --> 01:39:22,800
就带来一堆的问题

3162
01:39:22,866 --> 01:39:23,700
什么问题啊

3163
01:39:23,766 --> 01:39:24,766
一个是成本

3164
01:39:24,766 --> 01:39:26,366
它跟 gc 差不多了啊

3165
01:39:26,366 --> 01:39:27,800
它的它的这个成本跟 gc

3166
01:39:27,800 --> 01:39:28,200
就是那个 

3167
01:39:28,700 --> 01:39:30,766
Garbage Collection 的那个东西差不多了

3168
01:39:30,766 --> 01:39:31,866
这是一个成本

3169
01:39:31,966 --> 01:39:34,366
第二个有一个额外的一个负担

3170
01:39:34,366 --> 01:39:35,200
这个负担是什么

3171
01:39:35,200 --> 01:39:37,400
你得有一个 handle 和指针的一个什么

3172
01:39:37,400 --> 01:39:38,366
映射表

3173
01:39:38,433 --> 01:39:40,166
而且这个表还是动态的

3174
01:39:40,166 --> 01:39:42,500
因为你这里面分过来的这个内存呢

3175
01:39:42,500 --> 01:39:43,300
它是什么

3176
01:39:43,700 --> 01:39:44,766
它是变的嘛

3177
01:39:44,900 --> 01:39:46,066
比如说我有的时候

3178
01:39:46,066 --> 01:39:48,933
一个页里面就可能两三个分配的块

3179
01:39:49,233 --> 01:39:49,866
有的时候呢

3180
01:39:49,866 --> 01:39:52,333
可能小小的大概有上千个

3181
01:39:52,333 --> 01:39:52,733
是吧

3182
01:39:52,733 --> 01:39:53,566
这不是吗

3183
01:39:53,700 --> 01:39:54,233
对不对

3184
01:39:54,233 --> 01:39:55,500
还有什么问题呢

3185
01:39:55,666 --> 01:39:56,466
还有

3186
01:39:57,066 --> 01:39:58,366
就刚才讲的那个

3187
01:39:58,666 --> 01:40:00,100
就是使用上的麻烦

3188
01:40:00,100 --> 01:40:02,300
你得再增加一个接口

3189
01:40:02,300 --> 01:40:02,933
这个接口呢

3190
01:40:02,933 --> 01:40:05,133
是通过 handle 来返回这个地址

3191
01:40:05,400 --> 01:40:06,233
这样的话呢

3192
01:40:06,233 --> 01:40:08,533
就跟我们的这个 C 程序的这个

3193
01:40:08,533 --> 01:40:10,966
简洁的这个就发生了冲突了

3194
01:40:11,300 --> 01:40:12,866
所以呢在 Linux 底下

3195
01:40:12,966 --> 01:40:16,766
包括所有的我在搞嵌入式的那个

3196
01:40:16,766 --> 01:40:18,100
就是 RTOS 上跑的系统

3197
01:40:18,100 --> 01:40:19,933
我也遇到过很多

3198
01:40:20,066 --> 01:40:20,533
但是呢

3199
01:40:20,533 --> 01:40:25,266
我从来没见过支持堆的碎片整理的情况

3200
01:40:25,266 --> 01:40:26,066
也就是说

3201
01:40:26,166 --> 01:40:27,200
很多人可能尝试过

3202
01:40:27,200 --> 01:40:28,900
但尝试的结果是得不偿失

3203
01:40:29,100 --> 01:40:29,900
得不偿失

3204
01:40:30,366 --> 01:40:31,600
我们再来看看

3205
01:40:31,600 --> 01:40:33,766
大型项目的内存管理

3206
01:40:33,766 --> 01:40:35,466
这个我就简单过一下

3207
01:40:35,466 --> 01:40:37,500
因为这个可能对很多人来讲的话

3208
01:40:37,500 --> 01:40:38,666
就比较高深了

3209
01:40:39,166 --> 01:40:41,100
首先呢就是在一些大的这个

3210
01:40:41,100 --> 01:40:42,600
尤其是 C++ 这个

3211
01:40:42,600 --> 01:40:43,733
它会导致什么

3212
01:40:43,733 --> 01:40:45,066
就是内存的管理呢

3213
01:40:45,066 --> 01:40:46,800
它就是会越来越多啊

3214
01:40:47,300 --> 01:40:48,900
那个自定义的这个堆

3215
01:40:49,433 --> 01:40:50,133
所以的话呢

3216
01:40:50,133 --> 01:40:52,100
在 C++ 这个环境里边

3217
01:40:52,266 --> 01:40:56,400
我们经常会使用一些自己的堆管理算法

3218
01:40:56,400 --> 01:40:57,900
就比如说 WTF

3219
01:40:58,000 --> 01:40:59,233
WTF 指什么呢

3220
01:40:59,366 --> 01:41:01,833
指的是 Web Template Foundation

3221
01:41:01,833 --> 01:41:04,033
就是一个库，模板库

3222
01:41:04,033 --> 01:41:05,600
这个模板库里边呢

3223
01:41:05,600 --> 01:41:07,600
它提供了一个叫 bmalloc

3224
01:41:07,700 --> 01:41:10,200
用  libpas 来替代

3225
01:41:10,400 --> 01:41:12,300
大家有兴趣的话可以去看一下

3226
01:41:12,300 --> 01:41:13,966
那还有一个就是 glib

3227
01:41:13,966 --> 01:41:18,033
它是一个 C 的标准的工具库

3228
01:41:18,033 --> 01:41:19,366
这个工具库里面

3229
01:41:19,366 --> 01:41:22,100
提供了一个叫 g_slice  的分配接口

3230
01:41:22,233 --> 01:41:23,700
这个分配接口是干什么的

3231
01:41:23,766 --> 01:41:26,500
就是单独的一个堆的实现

3232
01:41:26,833 --> 01:41:30,200
专门用来分配固定大小的结构

3233
01:41:30,500 --> 01:41:31,900
就比如说你在这个程序里面

3234
01:41:31,900 --> 01:41:34,066
经常会分配一个固定大小的数据结构

3235
01:41:34,366 --> 01:41:37,100
那我们就用 g_slice

3236
01:41:37,500 --> 01:41:38,866
然后我们再来看一看

3237
01:41:38,866 --> 01:41:40,966
脚本语言的这个内存管理

3238
01:41:41,633 --> 01:41:43,166
通常脚本语言呢

3239
01:41:43,600 --> 01:41:46,033
都会用自己的一个数据结构

3240
01:41:46,100 --> 01:41:48,800
脚本语言的解释器通常用 C 或者是 C++

3241
01:41:48,800 --> 01:41:51,200
比如说 Python  JavaScript 都是这样，对吧

3242
01:41:51,400 --> 01:41:53,100
然后封装起来

3243
01:41:53,100 --> 01:41:55,866
比如说 JavaScript 一般叫 JSValue

3244
01:41:55,866 --> 01:41:58,066
Python 叫做 PyObject

3245
01:41:58,433 --> 01:41:59,000
这些东西呢

3246
01:41:59,000 --> 01:41:59,500
都是什么呢

3247
01:41:59,500 --> 01:42:00,766
都是一个结构

3248
01:42:00,766 --> 01:42:02,200
结构里面再去封装

3249
01:42:02,433 --> 01:42:05,700
封装成里面包含一个什么内容这个内容的

3250
01:42:05,700 --> 01:42:07,300
我们给大家看一看啊

3251
01:42:07,300 --> 01:42:09,333
大概是这样一个结构是长什么样

3252
01:42:11,433 --> 01:42:12,600
我们看的是呢

3253
01:42:14,766 --> 01:42:19,200
HVML 解释器里边的这个 variant

3254
01:42:19,200 --> 01:42:20,166
variant

3255
01:42:20,166 --> 01:42:24,133
就是我们 HVML 这个语言的解释器

3256
01:42:24,366 --> 01:42:25,333
它叫 PurC

3257
01:42:25,333 --> 01:42:26,966
跟 JavaScript 解释器类似

3258
01:42:27,066 --> 01:42:28,133
它里面的这些数据啊

3259
01:42:28,133 --> 01:42:30,233
比如说是一个整数也好

3260
01:42:30,233 --> 01:42:31,300
一个浮点数也好

3261
01:42:31,300 --> 01:42:32,233
一个字符串也好

3262
01:42:32,233 --> 01:42:34,366
它都是用这样一个结构来代表的

3263
01:42:34,433 --> 01:42:36,800
用一个 C 的结构来代表的

3264
01:42:37,033 --> 01:42:37,966
你比如说呢

3265
01:42:38,200 --> 01:42:38,900
一上来呢

3266
01:42:38,900 --> 01:42:39,600
它是几个

3267
01:42:39,600 --> 01:42:42,000
这个用预位的方式

3268
01:42:42,233 --> 01:42:44,366
类型，它的大小

3269
01:42:44,466 --> 01:42:45,633
然后一些标志

3270
01:42:46,200 --> 01:42:48,033
然后呢其中有一个 reference count

3271
01:42:48,400 --> 01:42:50,366
reference count 一个引用计数

3272
01:42:50,866 --> 01:42:52,600
然后呢就有一个什么呢

3273
01:42:52,600 --> 01:42:53,833
一个 listeners

3274
01:42:54,666 --> 01:42:55,600
一个 reserved

3275
01:42:56,066 --> 01:42:57,100
这是什么意思呢

3276
01:42:57,100 --> 01:42:59,633
就是我们可以在这个 variant 上

3277
01:42:59,633 --> 01:43:01,233
去设置一些监听器

3278
01:43:01,300 --> 01:43:03,366
比如说在一个数组里面

3279
01:43:03,366 --> 01:43:04,433
我增加一个东西的时候

3280
01:43:04,433 --> 01:43:05,300
你可以去调

3281
01:43:05,366 --> 01:43:07,033
这样就会产生一个事件

3282
01:43:07,033 --> 01:43:07,766
这个东西呢

3283
01:43:07,766 --> 01:43:09,500
就是用一个 list head

3284
01:43:09,533 --> 01:43:12,033
一个双向链表来维护的

3285
01:43:12,033 --> 01:43:12,900
而这个东西呢

3286
01:43:12,900 --> 01:43:15,200
为什么要变成了一个 union

3287
01:43:15,200 --> 01:43:16,433
就是一个联合呢

3288
01:43:16,466 --> 01:43:19,633
是因为我们把这个结构释放了之后

3289
01:43:19,633 --> 01:43:22,400
我们不会立即就释放到系统里边

3290
01:43:22,400 --> 01:43:24,233
我会把它暂存起来

3291
01:43:24,366 --> 01:43:25,700
这个就叫 reserved

3292
01:43:25,900 --> 01:43:26,333
对吧

3293
01:43:26,700 --> 01:43:28,466
这俩东西不是刚好是同一个吗

3294
01:43:28,466 --> 01:43:30,066
只不过取了个不同的名字而已

3295
01:43:30,066 --> 01:43:31,700
这样可读性好一点

3296
01:43:31,800 --> 01:43:32,400
所以呢

3297
01:43:32,400 --> 01:43:33,200
用一个 union

3298
01:43:33,200 --> 01:43:34,433
还有一个双向链表

3299
01:43:35,766 --> 01:43:37,400
然后底下就是 value了

3300
01:43:37,400 --> 01:43:39,366
它也用一个 union

3301
01:43:40,433 --> 01:43:41,466
为什么要用 Union 呢

3302
01:43:41,466 --> 01:43:41,800
对吧

3303
01:43:41,800 --> 01:43:43,266
因为这个类型里边

3304
01:43:43,266 --> 01:43:45,833
可以包括很多很多这个数据类型去

3305
01:43:45,833 --> 01:43:46,666
比如说是 b

3306
01:43:46,666 --> 01:43:47,766
那就 boolean 嘛

3307
01:43:48,033 --> 01:43:49,666
然后 atom 它是什么呢

3308
01:43:49,666 --> 01:43:51,300
一个叫做原子字符串

3309
01:43:51,966 --> 01:43:52,566
再往下呢

3310
01:43:52,566 --> 01:43:56,066
是一个比如说就是 number ，d

3311
01:43:56,066 --> 01:43:56,800
integer

3312
01:43:57,266 --> 01:43:58,833
unsigned long integer

3313
01:43:58,833 --> 01:44:00,233
或者是 long double

3314
01:44:00,466 --> 01:44:01,266
然后呢

3315
01:44:01,433 --> 01:44:03,766
有的时候我们要用两个指针

3316
01:44:03,766 --> 01:44:04,600
来保存它

3317
01:44:04,600 --> 01:44:05,700
就比如说举个例子啊

3318
01:44:05,700 --> 01:44:06,400
在这里边

3319
01:44:06,533 --> 01:44:09,200
一个什么 byte sequence

3320
01:44:09,200 --> 01:44:10,400
我们就可以用

3321
01:44:10,400 --> 01:44:12,200
第一个用 size 来

3322
01:44:12,200 --> 01:44:16,100
第一个用来记录它的字节的长度

3323
01:44:16,133 --> 01:44:17,000
然后第二个呢

3324
01:44:17,000 --> 01:44:18,800
用来保存它的这个 pointer

3325
01:44:18,833 --> 01:44:19,333
对吧

3326
01:44:19,900 --> 01:44:20,866
就是这样一个结构

3327
01:44:20,866 --> 01:44:22,200
你看这样一个结构呢

3328
01:44:22,500 --> 01:44:24,833
在我们的这个真正的啊

3329
01:44:25,400 --> 01:44:27,900
真正的我们去分配这个结构的时候

3330
01:44:27,900 --> 01:44:29,200
是怎么分配的呢

3331
01:44:29,200 --> 01:44:30,666
我们可以看一下

3332
01:44:44,266 --> 01:44:46,700
你看，我们每次分配的时候呢

3333
01:44:46,700 --> 01:44:47,700
真正分配的时候

3334
01:44:47,700 --> 01:44:49,800
如果是用了glib

3335
01:44:50,000 --> 01:44:53,266
然后呢我就 g_slice_alloc

3336
01:44:53,266 --> 01:44:54,166
就会用它

3337
01:44:54,200 --> 01:44:57,100
如果这个系统里面没有 glib

3338
01:44:57,133 --> 01:45:00,166
我们就直接用 malloc 或者 calloc

3339
01:45:01,000 --> 01:45:01,966
就是这样

3340
01:45:03,366 --> 01:45:05,733
这是一种在内存管理里边

3341
01:45:05,733 --> 01:45:07,700
就脚本语言的这个内存管

3342
01:45:08,166 --> 01:45:09,166
大家感兴趣的话

3343
01:45:09,166 --> 01:45:11,300
可以去阅读 QuickJS

3344
01:45:11,366 --> 01:45:12,900
或者是 JerryScript

3345
01:45:12,900 --> 01:45:15,866
这种小型的 JavaScript 引擎

3346
01:45:15,966 --> 01:45:17,533
它里面是怎么管理内存的

3347
01:45:17,533 --> 01:45:19,466
实际上这些东西基本上都很像

3348
01:45:19,733 --> 01:45:21,433
那 Python 的这个内存管理啊

3349
01:45:21,433 --> 01:45:22,166
这些东西呢

3350
01:45:22,166 --> 01:45:23,466
它是用什么

3351
01:45:23,566 --> 01:45:25,533
一个叫 CPython 的东西

3352
01:45:25,533 --> 01:45:27,500
用 C 来实现的 Python 解释器

3353
01:45:27,600 --> 01:45:28,933
它里面这个东西呢也很像

3354
01:45:28,933 --> 01:45:30,700
但是 JavaScript 和 Python

3355
01:45:30,700 --> 01:45:32,400
它是带有垃圾回收的

3356
01:45:32,466 --> 01:45:33,100
那所以呢

3357
01:45:33,100 --> 01:45:34,533
它会引入一些东西

3358
01:45:34,533 --> 01:45:37,200
比如说强引用/弱引用这些东西

3359
01:45:37,200 --> 01:45:38,966
强引用就是你你没有在这个 scope 里面

3360
01:45:38,966 --> 01:45:40,466
它就一直是有效的

3361
01:45:40,466 --> 01:45:41,466
弱引用就是说

3362
01:45:41,466 --> 01:45:45,000
一旦你跑过了这个

3363
01:45:45,000 --> 01:45:45,733
就是 scope

3364
01:45:45,733 --> 01:45:48,533
它马上就可以被回收

3365
01:45:49,000 --> 01:45:51,933
那我们刚才看到的 HVML 解释器

3366
01:45:52,000 --> 01:45:55,400
那我们是用 variant 这种方式

3367
01:45:55,466 --> 01:45:57,300
然后我们用的是引用计数

3368
01:45:57,366 --> 01:45:59,300
但是呢我们没有垃圾回收器

3369
01:45:59,300 --> 01:46:02,600
这个跟我们 HVML 程序的特点是有关系的

3370
01:46:02,600 --> 01:46:06,033
它是一个树的这种方式来管理程序

3371
01:46:06,033 --> 01:46:06,400
所以呢

3372
01:46:06,400 --> 01:46:09,000
这里面我们没有设计这个垃圾回收器

3373
01:46:09,433 --> 01:46:11,533
而且呢还有一个特别有意思的

3374
01:46:11,533 --> 01:46:14,333
我们采用了一个叫做跨线程的数据传递

3375
01:46:14,366 --> 01:46:15,166
叫 move heap

3376
01:46:15,500 --> 01:46:15,933
什么意思

3377
01:46:15,933 --> 01:46:18,733
呢就是我们在一个进程里面

3378
01:46:18,733 --> 01:46:20,900
可以有多个解释器的

3379
01:46:20,900 --> 01:46:23,166
就是 HVML 解释器的实例

3380
01:46:23,166 --> 01:46:24,400
它是每一个实例

3381
01:46:24,400 --> 01:46:26,766
是以单独的线程的方式运行的

3382
01:46:26,966 --> 01:46:30,500
然后各自在各自的这个 heap

3383
01:46:30,533 --> 01:46:33,633
堆里面去分配这个就是 variant 这个东西

3384
01:46:33,800 --> 01:46:36,033
然后我如果我要把这个东西呢

3385
01:46:36,033 --> 01:46:36,766
一个数据啊

3386
01:46:36,766 --> 01:46:39,166
从 a 线程转移到另外一个线程的时候

3387
01:46:39,166 --> 01:46:41,666
我们用了一个叫做 move head 的技术

3388
01:46:41,766 --> 01:46:43,933
而不是共享内存的技术

3389
01:46:43,933 --> 01:46:45,733
这一点是非常有意思的

3390
01:46:45,833 --> 01:46:47,666
因为通过这样一个东西之后啊

3391
01:46:47,666 --> 01:46:49,966
我们可以让这个锁

3392
01:46:50,833 --> 01:46:51,733
就是因为大家都知道

3393
01:46:51,733 --> 01:46:52,966
如果你一旦共享数据

3394
01:46:52,966 --> 01:46:54,233
你就得加锁嘛

3395
01:46:54,500 --> 01:46:56,866
加锁呢，你就得有一个全局的什么

3396
01:46:56,866 --> 01:47:00,766
就像那个 Python 里边有个叫做 GIL

3397
01:47:00,766 --> 01:47:01,333
那个东西呢

3398
01:47:01,333 --> 01:47:05,233
就是 Global Interpreter Lock

3399
01:47:05,233 --> 01:47:06,633
就是一个全局的锁

3400
01:47:06,900 --> 01:47:08,166
那全局的锁的话呢

3401
01:47:08,166 --> 01:47:09,333
那就会导致什么

3402
01:47:09,500 --> 01:47:12,566
所有的这个解释器就会暂停啊

3403
01:47:12,700 --> 01:47:15,100
但是 HVML PurC 这个实现里面

3404
01:47:15,100 --> 01:47:17,433
就没有用这样的方法去实现它

3405
01:47:17,566 --> 01:47:19,100
而是通过一个叫做 move heap

3406
01:47:19,100 --> 01:47:21,466
一个中间地带的东西来实现的

3407
01:47:21,500 --> 01:47:23,266
这个数据的传输

3408
01:47:23,300 --> 01:47:25,833
就是我们认为，数据，对吧

3409
01:47:25,833 --> 01:47:27,800
从一个实例转移到另外一个实例

3410
01:47:27,800 --> 01:47:29,300
实际上是数据的一个转移

3411
01:47:29,300 --> 01:47:30,600
而不是共享的一个过程

3412
01:47:30,600 --> 01:47:31,133
所以的话

3413
01:47:31,133 --> 01:47:33,600
我们用了一个叫 move heap 一个中间过程

3414
01:47:33,933 --> 01:47:35,033
这个东西

3415
01:47:35,066 --> 01:47:37,533
就是它是维护了一个队列来接受数据的

3416
01:47:37,666 --> 01:47:38,433
这个东西呢

3417
01:47:38,433 --> 01:47:40,266
大家有兴趣的话可以去看一下

3418
01:47:40,266 --> 01:47:42,533
我告诉大家这个代码在哪里

3419
01:47:42,866 --> 01:47:45,533
这个 move heap 就在这

3420
01:47:45,933 --> 01:47:48,133
如果大家看这个 PurC 的源代码

3421
01:47:48,133 --> 01:47:50,300
这都是开源的

3422
01:47:50,300 --> 01:47:52,166
它就在这个 purc 源代码

3423
01:47:52,166 --> 01:47:53,333
Source/PurC/variant 

3424
01:47:53,333 --> 01:47:55,000
底下有个 move-heap.c

3425
01:47:55,300 --> 01:47:56,333
大家可以去看一下

3426
01:47:56,333 --> 01:47:58,800
而且它里边还使用了一个无锁的设计

3427
01:47:58,800 --> 01:48:00,533
当然里边也有一个锁啊

3428
01:48:00,533 --> 01:48:03,233
但是那个锁是一个只用于中间地带的

3429
01:48:03,233 --> 01:48:04,266
锁那个中间地带

3430
01:48:04,266 --> 01:48:06,566
那个是对性能的影响几乎可以忽略

3431
01:48:06,900 --> 01:48:08,233
好我们今天总结一下啊

3432
01:48:08,266 --> 01:48:10,933
这个标题不应该是虚拟内存原理

3433
01:48:10,933 --> 01:48:13,433
应该是 高效使用内存的技巧

3434
01:48:13,566 --> 01:48:14,000
什么呢

3435
01:48:14,000 --> 01:48:16,366
就是说有几点要给大家说的

3436
01:48:16,366 --> 01:48:16,833
第一个呢

3437
01:48:16,833 --> 01:48:19,966
就是能用栈解决的问题绝不用堆

3438
01:48:20,266 --> 01:48:22,233
我们后来写的很多函数

3439
01:48:22,233 --> 01:48:26,266
它的实现，里边就不会有 malloc 这种东西

3440
01:48:26,700 --> 01:48:28,966
然后呢这个你要你要做一件事情

3441
01:48:28,966 --> 01:48:30,833
你把东西参数传进来

3442
01:48:30,866 --> 01:48:33,366
我处理完了就返回给你一个东西

3443
01:48:33,666 --> 01:48:35,400
这里边没有 malloc

3444
01:48:35,500 --> 01:48:37,833
就是说你能不用 malloc 的时候

3445
01:48:37,833 --> 01:48:39,166
就不要用 malloc

3446
01:48:39,166 --> 01:48:42,066
然后呢比如说你偶尔的要用一下VR

3447
01:48:42,200 --> 01:48:43,666
就是变长的东西

3448
01:48:43,666 --> 01:48:44,566
你可以用什么呢

3449
01:48:44,600 --> 01:48:45,566
VLA

3450
01:48:45,566 --> 01:48:47,033
或者 alloca 这种东西

3451
01:48:47,033 --> 01:48:49,033
在栈里面去分配内存

3452
01:48:49,266 --> 01:48:50,133
然后呢还有一个呢

3453
01:48:50,133 --> 01:48:52,133
就尽量分配小块的内存

3454
01:48:52,433 --> 01:48:54,400
避免频繁分配大块内存

3455
01:48:54,400 --> 01:48:56,366
你看我们的这个碎片化

3456
01:48:56,633 --> 01:48:59,233
通常就是因为你分配这种大块的内存

3457
01:48:59,266 --> 01:49:00,666
而且还不释放

3458
01:49:00,700 --> 01:49:01,533
长时间占着

3459
01:49:01,733 --> 01:49:03,800
就是占着茅坑不拉屎的那种

3460
01:49:03,800 --> 01:49:06,200
就这种情况就会导致碎片化

3461
01:49:06,233 --> 01:49:06,633
所以

3462
01:49:06,633 --> 01:49:09,700
有效降低碎片化的方法是什么呢

3463
01:49:09,866 --> 01:49:12,000
尽量的分配小块的内存

3464
01:49:12,000 --> 01:49:13,533
避免频繁分配大块内存

3465
01:49:14,100 --> 01:49:17,300
这个是一个很重要的一个原则

3466
01:49:17,333 --> 01:49:17,900
那还有呢

3467
01:49:17,900 --> 01:49:19,900
就是当我们需要频繁的

3468
01:49:19,900 --> 01:49:22,266
大量分配同样大小内存的时候

3469
01:49:22,400 --> 01:49:25,000
用 g_slice 或者类似的机制进行管理

3470
01:49:25,000 --> 01:49:26,233
你自己可以写一个

3471
01:49:26,233 --> 01:49:26,866
但因为

3472
01:49:27,000 --> 01:49:31,433
因为一旦是这种内存块或者是一个特定的结构

3473
01:49:31,600 --> 01:49:33,633
它就你频繁的要分配

3474
01:49:33,633 --> 01:49:35,533
就比如说我们叫 variant 这种东西

3475
01:49:35,533 --> 01:49:36,766
那就是频繁分配

3476
01:49:36,833 --> 01:49:38,100
那我们就可以简单的

3477
01:49:38,100 --> 01:49:39,166
用自己的一些方式

3478
01:49:39,166 --> 01:49:40,000
去实现它

3479
01:49:40,000 --> 01:49:40,266
对吧

3480
01:49:40,266 --> 01:49:41,600
我们目前的这个实现

3481
01:49:41,600 --> 01:49:42,766
它就用了 g_slice

3482
01:49:42,766 --> 01:49:44,666
因为分配的这些内存呢

3483
01:49:44,666 --> 01:49:46,666
它就是固定的嘛

3484
01:49:47,366 --> 01:49:50,633
所以呢就不会出现那碎片化，对吧

3485
01:49:50,633 --> 01:49:52,466
你想，每一次我都分配

3486
01:49:52,700 --> 01:49:54,733
比如说 16 个字节

3487
01:49:54,733 --> 01:49:56,933
我在一个 4K 的页里面去分配

3488
01:49:56,933 --> 01:49:58,500
它怎么可能碎片化呢

3489
01:49:58,833 --> 01:49:59,700
要有就是有

3490
01:49:59,700 --> 01:50:00,700
要没有就是没有

3491
01:50:00,700 --> 01:50:01,666
对吧

3492
01:50:01,666 --> 01:50:02,333
这就是

3493
01:50:02,333 --> 01:50:03,033
所以呢

3494
01:50:03,033 --> 01:50:04,300
这里边就讲到这个

3495
01:50:04,300 --> 01:50:05,900
一个内存的这个技巧

3496
01:50:05,900 --> 01:50:07,700
就是使高效使用内存的技巧

3497
01:50:07,700 --> 01:50:09,666
123 大家一定要记住啊

3498
01:50:09,666 --> 01:50:10,466
一定要记住

3499
01:50:10,566 --> 01:50:12,300
好今天的内容差不多了

3500
01:50:12,300 --> 01:50:14,166
我们布置下作业啊

3501
01:50:14,566 --> 01:50:16,966
这里面呢给大家呢就是几个东西啊

3502
01:50:16,966 --> 01:50:20,233
第一个就是阅读一下开源的代码

3503
01:50:20,366 --> 01:50:23,166
这里面其中有 glib 中的 g_slice 分配器

3504
01:50:23,166 --> 01:50:25,866
我给了那个地址啊

3505
01:50:26,000 --> 01:50:30,833
然后是 WTF 中的 bmalloc 分配器和 libpas 这些东西

3506
01:50:31,100 --> 01:50:36,100
然后是 PurC 中的变体管理及 move heap 代码

3507
01:50:36,600 --> 01:50:39,266
然后呢我希望大家用 Buddy 算法

3508
01:50:39,266 --> 01:50:41,100
就我今天在课上讲过的那个

3509
01:50:41,100 --> 01:50:42,466
Buddy 那个简单的算法

3510
01:50:42,466 --> 01:50:44,900
实现一个私有堆的管理模块

3511
01:50:45,000 --> 01:50:46,400
但是要求呢

3512
01:50:47,100 --> 01:50:50,100
和 C 库的 malloc/free 对比性能

3513
01:50:50,100 --> 01:50:50,566
就比如说

3514
01:50:50,566 --> 01:50:54,066
我同样用自己的这个接口和 malloc/free

3515
01:50:54,400 --> 01:50:56,466
你去对比一下，谁快

3516
01:50:56,800 --> 01:50:58,000
那第一个要求是

3517
01:50:58,000 --> 01:51:00,600
使用线程局部存储来管理线程私有堆

3518
01:51:00,600 --> 01:51:00,966
就是说

3519
01:51:00,966 --> 01:51:03,233
你对每一个线程都可以有一个私有堆

3520
01:51:03,600 --> 01:51:05,300
这样的话你就不要用锁了嘛

3521
01:51:05,600 --> 01:51:05,866
对吧

3522
01:51:05,866 --> 01:51:06,600
有一个好处

3523
01:51:06,600 --> 01:51:07,433
不用锁嘛

3524
01:51:07,433 --> 01:51:07,733
对

3525
01:51:07,866 --> 01:51:09,066
然后呢另外呢

3526
01:51:09,066 --> 01:51:11,700
就是衡量私有堆的内存使用效率

3527
01:51:11,700 --> 01:51:12,833
什么叫使用效率呢

3528
01:51:12,833 --> 01:51:13,966
就是一个是

3529
01:51:14,100 --> 01:51:15,533
就是你的碎片的这种

3530
01:51:15,533 --> 01:51:16,666
就是空闲的

3531
01:51:16,666 --> 01:51:17,700
比例，是吧

3532
01:51:17,700 --> 01:51:18,366
然后呢

3533
01:51:18,366 --> 01:51:18,766
这样子

3534
01:51:19,066 --> 01:51:21,300
这是个需要编程实现的

3535
01:51:21,300 --> 01:51:22,633
实际上这个代码呢

3536
01:51:22,666 --> 01:51:25,200
在我的另外一个开源项目

3537
01:51:25,200 --> 01:51:26,800
就 MiniGUI 里面有

3538
01:51:26,800 --> 01:51:27,800
你们先写

3539
01:51:28,000 --> 01:51:28,866
写完了之后呢

3540
01:51:28,866 --> 01:51:30,433
我把那个链接给你们

3541
01:51:30,533 --> 01:51:32,166
然后你们去对照一下我的版本

3542
01:51:32,166 --> 01:51:33,166
和你的版本

3543
01:51:33,466 --> 01:51:37,166
当然我那个版本不是线程私有堆

3544
01:51:37,233 --> 01:51:38,833
就是有一个全局

3545
01:51:39,066 --> 01:51:40,466
全局的那个东西在

3546
01:51:40,533 --> 01:51:41,866
管着啊

3547
01:51:41,866 --> 01:51:43,400
好，再往下的话呢

3548
01:51:43,400 --> 01:51:45,000
就是我们的第二讲了啊

3549
01:51:45,133 --> 01:51:45,766
这一讲呢

3550
01:51:45,766 --> 01:51:48,100
就主要讲这个文件和文件系统

3551
01:51:48,100 --> 01:51:51,300
这里边就是大家需要预习一下

3552
01:51:51,300 --> 01:51:52,433
就是回顾一下

3553
01:51:52,466 --> 01:51:54,366
就是比如说 STDIO

3554
01:51:54,700 --> 01:51:56,333
文件描述符

3555
01:51:56,333 --> 01:51:56,833
FILE

3556
01:51:56,833 --> 01:51:59,033
就是我们 stdio 里面那个 file

3557
01:51:59,033 --> 01:52:01,333
和文件描述符的关系是啥啊

3558
01:52:01,866 --> 01:52:03,666
然后重定向和管道

3559
01:52:03,733 --> 01:52:05,200
这些东西是怎么实现的

3560
01:52:05,200 --> 01:52:07,433
那这个东西还相对来讲比较简单

3561
01:52:07,433 --> 01:52:08,500
Linux 内核里面

3562
01:52:08,666 --> 01:52:11,066
这个机制也相对来讲比较容易

3563
01:52:11,333 --> 01:52:12,066
容易理解

3564
01:52:12,300 --> 01:52:14,933
还有就文件系统的这个操作接口

3565
01:52:14,933 --> 01:52:16,133
就是文件系统的操作

3566
01:52:16,133 --> 01:52:17,433
不是文件的操作接口

3567
01:52:17,433 --> 01:52:18,700
文件系统的操作接口

3568
01:52:18,700 --> 01:52:21,166
这个很多人可能不太熟

3569
01:52:21,166 --> 01:52:22,366
对文件的操作接口呢

3570
01:52:22,366 --> 01:52:22,966
大家很熟

3571
01:52:23,633 --> 01:52:25,600
文件系统的操作接口也复习一下

3572
01:52:26,000 --> 01:52:26,966
然后我们再来看看

3573
01:52:26,966 --> 01:52:29,533
Linux 当中常用的一些文件系统类型

3574
01:52:29,533 --> 01:52:33,800
因为除了我们真实存储数据的那些

3575
01:52:33,800 --> 01:52:35,566
就文件的那个文件系统之外

3576
01:52:35,566 --> 01:52:37,166
现在又出现了很多很多

3577
01:52:37,166 --> 01:52:40,366
那种用户态的这个文件系统

3578
01:52:40,633 --> 01:52:43,333
还有一些什么 Overlay

3579
01:52:43,333 --> 01:52:44,400
这样的一些文件系统

3580
01:52:44,400 --> 01:52:45,333
挺有意思的

3581
01:52:45,333 --> 01:52:46,900
我们再给大家在这里边呢

3582
01:52:46,900 --> 01:52:48,500
给大家做一些原理

3583
01:52:48,500 --> 01:52:50,733
或者什么方面的一些解释啊

3584
01:52:51,400 --> 01:52:52,633
好今天的内容呢

3585
01:52:52,700 --> 01:52:53,866
就到此为止了

3586
01:52:54,033 --> 01:52:54,900
嗯谢谢大家

